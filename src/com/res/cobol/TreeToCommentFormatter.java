//
// Generated by JTB 1.3.2
// Modified  by Venkat Krishnamurthy
//
package com.res.cobol;
/*****************************************************************************
Copyright 2009 Venkat Krishnamurthy
This file is part of RES.

RES is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

RES is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with RES.  If not, see <http://www.gnu.org/licenses/>.

@author VenkatK mailto: open.cobol.to.java at gmail.com
******************************************************************************/
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Enumeration;

import com.res.cobol.parser.CobolParserTokenManager;
import com.res.cobol.parser.Token;
import com.res.cobol.syntaxtree.DataDescriptionEntry;
import com.res.cobol.syntaxtree.NodeToken;
import com.res.cobol.syntaxtree.Statement;
import com.res.cobol.visitor.DepthFirstVisitor;
import com.res.common.RESConfig;
import com.res.java.lib.RunTimeUtil;
import com.res.java.util.ClassFile;
import com.res.java.util.ClassFileWriter;

/**
 * Dumps the syntax tree to a Writer using the location information in
 * each NodeToken.
 */
public class TreeToCommentFormatter extends DepthFirstVisitor {
   protected ClassFileWriter out;
   private int curLine = 1;
   private int curColumn = 1;
   private boolean startAtNextToken = false;
   private boolean printSpecials = true;
   private boolean isOutputToTrackClassFiles=false;
   private int classFileCommentLines=0;
   private int firstCommentLineColumnNum=0;
   /**
    * The default constructor uses System.out as its output location.
    * You may specify your own Writer or OutputStream using one of the
    * other constructors.
    */
   public TreeToCommentFormatter()       { 
		   out = new ClassFileWriter(System.out);
   	}

   public TreeToCommentFormatter(OutputStream o)  { 
		out = new ClassFileWriter(new PrintStream(o));
   }
   
   public TreeToCommentFormatter(ClassFileWriter o)  { 
		out = o;
  }
   
   public TreeToCommentFormatter(boolean b)  { out=null;isOutputToTrackClassFiles=true;printSpecials(b);}

   /**
    * Flushes the OutputStream or Writer that this TreeDumper is using.
    */
   public void flushWriter()        { out.flush(); }

   /**
    * Allows you to specify whether or not to print special tokens.
    */
   public void printSpecials(boolean b)   { printSpecials = b; }

   /**
    * Starts the tree dumper on the line containing the next token
    * visited.  For example, if the next token begins on line 50 and the
    * dumper is currently on line 1 of the file, it will set its current
    * line to 50 and continue printing from there, as opposed to
    * printing 49 blank lines and then printing the token.
    */
   public void startAtNextToken()   { 
	   startAtNextToken = true;
	   classFileCommentLines=0;
	   if(isOutputToTrackClassFiles) {
			 out=ClassFile.current;
	   }
   }

   /**
    * Resets the position of the output "cursor" to the first line and
    * column.  When using a dumper on a syntax tree more than once, you
    * either need to call this method or startAtNextToken() between each
    * dump.
    */
   public void resetPosition()      { curLine = curColumn = 1; }

   @Override
   public void visit(Statement n) {
	   if(startAtNextToken)
		   super.visit(n);
   }
   
   @Override
   public void visit(DataDescriptionEntry n) {
	   if(startAtNextToken)
		   super.visit(n);
   }
/**
    * Dumps the current NodeToken to the output stream being used.
    *
    * @throws  IllegalStateException   if the token position is invalid
    *   relative to the current position, i.e. its location places it
    *   before the previous token.
    */
   public void visit(NodeToken n) {
	
     if(out==null)
		return;
	 if(RESConfig.getInstance().isRetainCobolComments()&&
			 startAtNextToken) {
    	 printCobolComments(n.beginLine);
    	 if(!RESConfig.getInstance().isPrintCobolStatementsAsComments())
    		 return;
	 }

      if ( n.beginLine == -1 || n.beginColumn == -1 ) {
         printToken(n.tokenImage);
         return;
      }

      //
      // Handle special tokens
      //
      if ( printSpecials && n.numSpecials() > 0 )
         for ( Enumeration<NodeToken> e = n.specialTokens.elements(); e.hasMoreElements(); )
            visit(e.nextElement());

      //
      // Handle startAtNextToken option
      //
      if ( startAtNextToken ) {
         curLine = n.beginLine;
         curColumn = n.beginColumn;
         startAtNextToken = false;

        
    	 if(isOutputToTrackClassFiles) {
    		 if(n.sourceFile!=null&&n.sourceFile.length()>0)
    			 out.println("//@CobolSourceFile(\""+n.sourceFile+"\","+String.valueOf(n.beginLine)+
    					 ","+String.valueOf(n.beginColumn)+") ");
    		 out.print("//");
    		 toPrintSlashes=false;
             classFileCommentLines=0;
             firstCommentLineColumnNum=n.beginColumn;
    	 }
    	 else
    		 if ( n.beginColumn < curColumn )
    			 out.println();
      }

      //
      // Check for invalid token position relative to current position.
      //
      if ( n.beginLine < curLine ) {
    	  if(isOutputToTrackClassFiles) {
              classFileCommentLines++;
     	 }
     	 else { 
     		 //out.print("#"+ String.valueOf(n.beginLine)+ " "+String.valueOf(curLine));
     		 //out.println(" \"<source-file-name-here>\"");
     	 }
         //throw new IllegalStateException("at token \"" + n.tokenImage +
           // "\", n.beginLine = " + Integer.toString(n.beginLine) +
           // ", curLine = " + Integer.toString(curLine));
      }
      else if ( n.beginLine == curLine && n.beginColumn < curColumn ) {
         //throw new IllegalStateException("at token \"" + n.tokenImage +
            //"\", n.beginColumn = " +
           // Integer.toString(n.beginColumn) + ", curColumn = " +
            //Integer.toString(curColumn));
      }

      //
      // Move output "cursor" to proper location, then print the token
      //
      boolean first=true,second=false,third=false;
      if ( curLine < n.beginLine ) {
    	 if(isOutputToTrackClassFiles)
             curColumn = firstCommentLineColumnNum;
    	 else
    		 curColumn = 1;
         for ( ; curLine < n.beginLine; ++curLine ) {
        	 if(isOutputToTrackClassFiles) {
        		 if(first) {
            		 ClassFile.println("");
            		 toPrintSlashes=true;
        			 first=false;
        			 second=true;
        		 } else if(second) 
        		 {
        			 ClassFile.print("//");
        			 toPrintSlashes=false;
        			 second=false;
        			 third=true;
        		 } else if(third){
        			 ClassFile.printPlain("...");
        			 toPrintSlashes=false;
        			 third=false;
        		 } else
        			 toPrintSlashes=false;
                 classFileCommentLines++;
        	 }
        	 else out.println("");
         }
      }
	   if(isOutputToTrackClassFiles) {
		   if(toPrintSlashes){
			 ClassFile.print("//");
			 toPrintSlashes=false;
		   }
	   }

      for ( ; curColumn < n.beginColumn; ++curColumn ){
          out.printPlain(' ');
      }

      printToken(n.tokenImage);
   }
   boolean toPrintSlashes=false,entering=false;
   private void printToken(String s) {

	   entering=true;
	   boolean prevCRLF=false;
      for ( int i = 0; i < s.length(); ++i ) { 
         if ( s.charAt(i) == '\n' ) {
            ++curLine;
            curColumn = 1;
         }
         else
            curColumn++;
         
         if(prevCRLF)
        	 if(RunTimeUtil.getInstance().isWhiteSpaces(s.charAt(i)))
        		 continue;
        	 else 
        	 if( !entering ){ ClassFile.print("//"); prevCRLF=false;toPrintSlashes=false;}
         
         if(s.charAt(i)=='\r'||s.charAt(i)=='\n'){
        	 prevCRLF=true;
        	 toPrintSlashes=true;
         } 
         out.printPlain(s.charAt(i));
         entering=false;
      }

      out.flush();
   }
   
   public void printCobolComments(int currLineNo) {
       if(RESConfig.getInstance().isRetainCobolComments()) {
      	 if(CobolParserTokenManager.commentLines!=null) {
      		 int i=0;
	        	 while(CobolParserTokenManager.commentLines.size()>i) {
	        		 Token cmt_t=(Token)CobolParserTokenManager.commentLines.get(i);
	        		 if(cmt_t==null||cmt_t.image==null) continue;
	        		 if(cmt_t.beginLine<=currLineNo) {
        				 out.println("//"+cmt_t.image.replace("*>", "*"));
	            		 CobolParserTokenManager.commentLines.remove(i);
	        		 } 
	        		 else 
	        			 break;
	        	 }
      	 }
       }
	   
   }
}
