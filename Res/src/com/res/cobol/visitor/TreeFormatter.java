//
// Generated by JTB 1.3.2
//
package com.res.cobol.visitor;

import com.res.cobol.syntaxtree.*;
import java.util.*;

/**
 * A skeleton output formatter for your language grammar.  Using the
 * add() method along with force(), indent(), and outdent(), you can
 * easily specify how this visitor will format the given syntax tree.
 * See the JTB documentation for more details.
 *
 * Pass your syntax tree to this visitor, and then to the TreeDumper
 * visitor in order to "pretty print" your tree.
 */
public class TreeFormatter extends DepthFirstVisitor {
   private Vector<FormatCommand> cmdQueue = new Vector<FormatCommand>();
   private boolean lineWrap;
   private int wrapWidth;
   private int indentAmt;
   private int curLine = 1;
   private int curColumn = 1;
   private int curIndent = 0;

   /**
    * The default constructor assumes an indentation amount of 3 spaces
    * and no line-wrap.  You may alternately use the other constructor to
    * specify your own indentation amount and line width.
    */
   public TreeFormatter() { this(3, 0); }

   /**
    * This constructor accepts an indent amount and a line width which is
    * used to wrap long lines.  If a token's beginColumn value is greater
    * than the specified wrapWidth, it will be moved to the next line and
    * indented one extra level.  To turn off line-wrapping, specify a
    * wrapWidth of 0.
    *
    * @param   indentAmt   Amount of spaces per indentation level.
    * @param   wrapWidth   Wrap lines longer than wrapWidth.  0 for no wrap.
    */
   public TreeFormatter(int indentAmt, int wrapWidth) {
      this.indentAmt = indentAmt;
      this.wrapWidth = wrapWidth;

      if ( wrapWidth > 0 )
         lineWrap = true;
      else
         lineWrap = false;
   }

   /**
    * Accepts a NodeListInterface object and performs an optional format
    * command between each node in the list (but not after the last node).
    */
   protected void processList(NodeListInterface n) {
      processList(n, null);
   }

   protected void processList(NodeListInterface n, FormatCommand cmd) {
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         if ( cmd != null && e.hasMoreElements() )
            cmdQueue.addElement(cmd);
      }
   }

   /**
    * A Force command inserts a line break and indents the next line to
    * the current indentation level.  Use "add(force());".
    */
   protected FormatCommand force() { return force(1); }
   protected FormatCommand force(int i) {
      return new FormatCommand(FormatCommand.FORCE, i);
   }

   /**
    * An Indent command increases the indentation level by one (or a
    * user-specified amount).  Use "add(indent());".
    */
   protected FormatCommand indent() { return indent(1); }
   protected FormatCommand indent(int i) {
      return new FormatCommand(FormatCommand.INDENT, i);
   }

   /**
    * An Outdent command is the reverse of the Indent command: it reduces
    * the indentation level.  Use "add(outdent());".
    */
   protected FormatCommand outdent() { return outdent(1); }
   protected FormatCommand outdent(int i) {
      return new FormatCommand(FormatCommand.OUTDENT, i);
   }

   /**
    * A Space command simply adds one or a user-specified number of
    * spaces between tokens.  Use "add(space());".
    */
   protected FormatCommand space() { return space(1); }
   protected FormatCommand space(int i) {
      return new FormatCommand(FormatCommand.SPACE, i);
   }

   /**
    * Use this method to add FormatCommands to the command queue to be
    * executed when the next token in the tree is visited.
    */
   protected void add(FormatCommand cmd) {
      cmdQueue.addElement(cmd);
   }

   /**
    * Executes the commands waiting in the command queue, then inserts the
    * proper location information into the current NodeToken.
    *
    * If there are any special tokens preceding this token, they will be
    * given the current location information.  The token will follow on
    * the next line, at the proper indentation level.  If this is not the
    * behavior you want from special tokens, feel free to modify this
    * method.
    */
   public void visit(NodeToken n) {
      for ( Enumeration<FormatCommand> e = cmdQueue.elements(); e.hasMoreElements(); ) {
         FormatCommand cmd = e.nextElement();
         switch ( cmd.getCommand() ) {
         case FormatCommand.FORCE :
            curLine += cmd.getNumCommands();
            curColumn = curIndent + 1;
            break;
         case FormatCommand.INDENT :
            curIndent += indentAmt * cmd.getNumCommands();
            break;
         case FormatCommand.OUTDENT :
            if ( curIndent >= indentAmt )
               curIndent -= indentAmt * cmd.getNumCommands();
            break;
         case FormatCommand.SPACE :
            curColumn += cmd.getNumCommands();
            break;
         default :
            throw new TreeFormatterException(
               "Invalid value in command queue.");
         }
      }

      cmdQueue.removeAllElements();

      //
      // Handle all special tokens preceding this NodeToken
      //
      if ( n.numSpecials() > 0 )
         for ( Enumeration<NodeToken> e = n.specialTokens.elements();
               e.hasMoreElements(); ) {
            NodeToken special = e.nextElement();

            //
            // -Place the token.
            // -Move cursor to next line after the special token.
            // -Don't update curColumn--want to keep current indent level.
            //
            placeToken(special, curLine, curColumn);
            curLine = special.endLine + 1;
         }

      placeToken(n, curLine, curColumn);
      curLine = n.endLine;
      curColumn = n.endColumn;
   }

   /**
    * Inserts token location (beginLine, beginColumn, endLine, endColumn)
    * information into the NodeToken.  Takes into account line-wrap.
    * Does not update curLine and curColumn.
    */
   private void placeToken(NodeToken n, int line, int column) {
      int length = n.tokenImage.length();

      //
      // Find beginning of token.  Only line-wrap for single-line tokens
      //
      if ( !lineWrap || n.tokenImage.indexOf('\n') != -1 ||
           column + length <= wrapWidth )
         n.beginColumn = column;
      else {
         ++line;
         column = curIndent + indentAmt + 1;
         n.beginColumn = column;
      }

      n.beginLine = line;

      //
      // Find end of token; don't count \n if it's the last character
      //
      for ( int i = 0; i < length; ++i ) {
         if ( n.tokenImage.charAt(i) == '\n' && i < length - 1 ) {
            ++line;
            column = 1;
         }
         else
            ++column;
      }

      n.endLine = line;
      n.endColumn = column;
   }

   //
   // User-generated visitor methods below
   //

   /**
    * <PRE>
    * nodeToken -> &lt;COBOL_WORD&gt;
    * </PRE>
    */
   public void visit(CobolWord n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;LEVEL_66&gt;
    *       | &lt;LEVEL_77&gt;
    *       | &lt;LEVEL_78&gt;
    *       | &lt;LEVEL_88&gt;
    *       | &lt;LEVEL_NUMBER&gt;
    *       | &lt;INTEGER&gt;
    *       | &lt;COMMA_INTEGER&gt;
    * </PRE>
    */
   public void visit(IntegerConstant n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> ( &lt;PLUSCHAR&gt; | &lt;MINUSCHAR&gt; )?
    * nodeChoice -> ( IntegerConstant() &lt;DOTCHAR&gt; [ IntegerConstant() ] | &lt;DOTCHAR&gt; IntegerConstant() | IntegerConstant() )
    * </PRE>
    */
   public void visit(NumericConstant n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;LEVEL_NUMBER&gt;
    * </PRE>
    */
   public void visit(LevelNumber n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;ZERO&gt;
    *       | &lt;ZEROS&gt;
    *       | &lt;ZEROES&gt;
    *       | &lt;SPACE&gt;
    *       | &lt;SPACES&gt;
    *       | &lt;HIGH_VALUE&gt;
    *       | &lt;HIGH_VALUES&gt;
    *       | &lt;LOW_VALUE&gt;
    *       | &lt;LOW_VALUES&gt;
    *       | &lt;QUOTE&gt;
    *       | &lt;QUOTES&gt;
    *       | &lt;NULL&gt;
    *       | &lt;NULLS&gt;
    * </PRE>
    */
   public void visit(FigurativeConstant n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;QUOTEDSTRING&gt; | &lt;HEXNUMBER&gt; )
    * </PRE>
    */
   public void visit(NonNumericConstant n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;ALL&gt; ]
    * nodeChoice -> ( NonNumericConstant() | NumericConstant() | FigurativeConstant() | IntrinsicFunction() | SpecialRegister() | &lt;LINAGE_COUNTER&gt; [ ( &lt;IN&gt; | &lt;OF&gt; ) FileName() ] )
    * </PRE>
    */
   public void visit(Literal n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * combinableCondition -> CombinableCondition()
    * nodeListOptional -> ( ( &lt;AND&gt; | &lt;OR&gt; ) ( CombinableCondition() | AbbreviationRest() ) )*
    * </PRE>
    */
   public void visit(Condition n) {
      n.combinableCondition.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;NOT&gt; ]
    * simpleCondition -> SimpleCondition()
    * </PRE>
    */
   public void visit(CombinableCondition n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.simpleCondition.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( ClassCondition() | RelationCondition() | ConditionNameCondition() | &lt;LPARENCHAR&gt; Condition() &lt;RPARENCHAR&gt; )
    * </PRE>
    */
   public void visit(SimpleCondition n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * identifier -> Identifier()
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeOptional1 -> [ &lt;NOT&gt; ]
    * nodeChoice -> ( &lt;NUMERIC&gt; | &lt;ALPHABETIC&gt; | &lt;ALPHABETIC_LOWER&gt; | &lt;ALPHABETIC_UPPER&gt; | ClassName() | &lt;DBCS&gt; | &lt;KANJI&gt; )
    * </PRE>
    */
   public void visit(ClassCondition n) {
      n.identifier.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * conditionNameReference -> ConditionNameReference()
    * </PRE>
    */
   public void visit(ConditionNameCondition n) {
      n.conditionNameReference.accept(this);
   }

   /**
    * <PRE>
    * arithmeticExpression -> ArithmeticExpression()
    * nodeChoice -> ( RelationalOperator() ArithmeticExpression() | SignCondition() )
    * </PRE>
    */
   public void visit(RelationCondition n) {
      n.arithmeticExpression.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeOptional1 -> [ &lt;NOT&gt; ]
    * nodeChoice -> ( &lt;POSITIVE&gt; | &lt;NEGATIVE&gt; | ( &lt;ZERO&gt; | &lt;ZEROS&gt; | &lt;ZEROES&gt; ) )
    * </PRE>
    */
   public void visit(SignCondition n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeOptional1 -> [ &lt;NOT&gt; ]
    * nodeChoice -> ( &lt;GREATER&gt; [ &lt;THAN&gt; ] &lt;OR&gt; &lt;EQUAL&gt; [ &lt;TO&gt; ] | &lt;MORETHANOREQUAL&gt; | &lt;LESS&gt; [ &lt;THAN&gt; ] &lt;OR&gt; &lt;EQUAL&gt; [ &lt;TO&gt; ] | &lt;LESSTHANOREQUAL&gt; | &lt;GREATER&gt; [ &lt;THAN&gt; ] | &lt;MORETHANCHAR&gt; | &lt;LESS&gt; [ &lt;THAN&gt; ] | &lt;LESSTHANCHAR&gt; | ( &lt;EQUAL&gt; | &lt;EQUALS&gt; ) [ &lt;TO&gt; ] | &lt;EQUALCHAR&gt; [ &lt;TO&gt; ] | &lt;NOTEQUALCHAR&gt; )
    * </PRE>
    */
   public void visit(RelationalOperator n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeList -> ( [ &lt;NOT&gt; ] [ RelationalOperator() ] AbbreviationLeaf() )+
    * </PRE>
    */
   public void visit(AbbreviationRest n) {
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> ( ArithmeticExpression() | &lt;LPARENCHAR&gt; ArithmeticExpression() AbbreviationRest() &lt;RPARENCHAR&gt; )
    * </PRE>
    */
   public void visit(AbbreviationLeaf n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( ParagraphName() [ ( &lt;IN&gt; | &lt;OF&gt; ) SectionName() ] | SectionName() )
    * </PRE>
    */
   public void visit(ProcedureName n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( QualifiedDataName() ( &lt;LPARENCHAR&gt; Subscript() ( [ &lt;COMMACHAR&gt; ] Subscript() )* &lt;RPARENCHAR&gt; )* [ &lt;LPARENCHAR&gt; LeftmostCharacterPosition() &lt;COLONCHAR&gt; [ Length() ] &lt;RPARENCHAR&gt; ] | &lt;RETURN_CODE&gt; )
    * </PRE>
    */
   public void visit(Identifier n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeSequence -> ( DataName() ( ( &lt;IN&gt; | &lt;OF&gt; ) DataName() )* [ ( &lt;IN&gt; | &lt;OF&gt; ) FileName() ] )
    * </PRE>
    */
   public void visit(QualifiedDataName n) {
      n.nodeSequence.accept(this);
   }

   /**
    * <PRE>
    * nodeSequence -> ( &lt;FUNCTION&gt; ( &lt;F_ACOS&gt; | &lt;F_ANNUITY&gt; | &lt;F_ASIN&gt; | &lt;F_ATAN&gt; | &lt;F_CHAR&gt; | &lt;F_COS&gt; | &lt;F_CURRENT_DATE&gt; | &lt;F_DATE_OF_INTEGER&gt; | &lt;F_DATE_TO_YYYYMMDD&gt; | &lt;F_DATEVAL&gt; | &lt;F_DAY_OF_INTEGER&gt; | &lt;F_DAY_TO_YYYYDDD&gt; | &lt;F_DISPLAY_OF&gt; | &lt;F_FACTORIAL&gt; | &lt;F_INTEGER&gt; | &lt;F_INTEGER_OF_DATE&gt; | &lt;F_INTEGER_OF_DAY&gt; | &lt;F_INTEGER_PART&gt; | &lt;F_LENGTH&gt; | &lt;F_LOG&gt; | &lt;F_LOG10&gt; | &lt;F_LOWER_CASE&gt; | &lt;F_MAX&gt; | &lt;F_MEAN&gt; | &lt;F_MEDIAN&gt; | &lt;F_MIDRANGE&gt; | &lt;F_MIN&gt; | &lt;F_MOD&gt; | &lt;F_NATIONAL_OF&gt; | &lt;F_NUMVAL&gt; | &lt;F_NUMVAL_C&gt; | &lt;F_ORD&gt; | &lt;F_ORD_MAX&gt; | &lt;F_ORD_MIN&gt; | &lt;F_PRESENT_VALUE&gt; | &lt;F_RANDOM&gt; | &lt;F_RANGE&gt; | &lt;F_REM&gt; | &lt;F_REVERSE&gt; | &lt;F_SIN&gt; | &lt;F_SQRT&gt; | &lt;F_STANDARD_DEVIATION&gt; | &lt;F_SUM&gt; | &lt;F_TAN&gt; | &lt;F_UNDATE&gt; | &lt;F_UPPER_CASE&gt; | &lt;F_VARIANCE&gt; | &lt;F_WHEN_COMPILED&gt; | &lt;F_YEAR_TO_YYYY&gt; | &lt;F_YEARWINDOW&gt; ) [ &lt;LPARENCHAR&gt; [ QualifiedDataName() &lt;LPARENCHAR&gt; ( &lt;ALL&gt; [ &lt;COMMACHAR&gt; ] )+ &lt;RPARENCHAR&gt; | FunctionArgument() ( [ &lt;COMMACHAR&gt; ] FunctionArgument() )* ] &lt;RPARENCHAR&gt; ] )
    * </PRE>
    */
   public void visit(IntrinsicFunction n) {
      n.nodeSequence.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> Identifier()
    *       | Literal()
    *       | ArithmeticExpression()
    * </PRE>
    */
   public void visit(FunctionArgument n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * arithmeticExpression -> ArithmeticExpression()
    * </PRE>
    */
   public void visit(Length n) {
      n.arithmeticExpression.accept(this);
   }

   /**
    * <PRE>
    * arithmeticExpression -> ArithmeticExpression()
    * </PRE>
    */
   public void visit(LeftmostCharacterPosition n) {
      n.arithmeticExpression.accept(this);
   }

   /**
    * <PRE>
    * conditionName -> ConditionName()
    * nodeChoice -> ( ( ( &lt;IN&gt; | &lt;OF&gt; ) DataName() )* [ ( &lt;IN&gt; | &lt;OF&gt; ) FileName() ] ( &lt;LPARENCHAR&gt; Subscript() ( [ &lt;COMMACHAR&gt; ] Subscript() )* &lt;RPARENCHAR&gt; )* | ( ( &lt;IN&gt; | &lt;OF&gt; ) MnemonicName() )* )
    * </PRE>
    */
   public void visit(ConditionNameReference n) {
      n.conditionName.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( [ ( &lt;PLUSCHAR_SUBS&gt; | &lt;PLUSCHAR&gt; ) | ( &lt;MINUSCHAR_SUBS&gt; | &lt;MINUSCHAR&gt; ) ] IntegerConstant() | QualifiedDataName() [ ( &lt;PLUSCHAR_SUBS&gt; | &lt;MINUSCHAR_SUBS&gt; ) IntegerConstant() ] | IndexName() [ ( &lt;PLUSCHAR_SUBS&gt; | &lt;MINUSCHAR_SUBS&gt; ) IntegerConstant() ] )
    * </PRE>
    */
   public void visit(Subscript n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(Mode n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(AlphabetName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(ClassName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(ConditionName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(DataName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(FileName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(IndexName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(MnemonicName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * qualifiedDataName -> QualifiedDataName()
    * </PRE>
    */
   public void visit(RecordName n) {
      n.qualifiedDataName.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(RoutineName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(SymbolicCharacter n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(LibraryName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(ProgramName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(CdName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;LEVEL_66&gt;
    *       | &lt;LEVEL_77&gt;
    *       | &lt;LEVEL_78&gt;
    *       | &lt;LEVEL_88&gt;
    *       | &lt;LEVEL_NUMBER&gt;
    *       | &lt;INTEGER&gt;
    *       | CobolWord()
    * </PRE>
    */
   public void visit(SectionName n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;LEVEL_66&gt;
    *       | &lt;LEVEL_77&gt;
    *       | &lt;LEVEL_78&gt;
    *       | &lt;LEVEL_88&gt;
    *       | &lt;LEVEL_NUMBER&gt;
    *       | &lt;INTEGER&gt;
    *       | CobolWord()
    * </PRE>
    */
   public void visit(ParagraphName n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * cobolWord -> CobolWord()
    * </PRE>
    */
   public void visit(SystemName n) {
      n.cobolWord.accept(this);
   }

   /**
    * <PRE>
    * systemName -> SystemName()
    * </PRE>
    */
   public void visit(ComputerName n) {
      n.systemName.accept(this);
   }

   /**
    * <PRE>
    * systemName -> SystemName()
    * </PRE>
    */
   public void visit(LanguageName n) {
      n.systemName.accept(this);
   }

   /**
    * <PRE>
    * systemName -> SystemName()
    * </PRE>
    */
   public void visit(EnvironmentName n) {
      n.systemName.accept(this);
   }

   /**
    * <PRE>
    * systemName -> SystemName()
    * </PRE>
    */
   public void visit(AssignmentName n) {
      n.systemName.accept(this);
   }

   /**
    * <PRE>
    * programName -> ProgramName()
    * </PRE>
    */
   public void visit(BasisName n) {
      n.programName.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;ADDRESS&gt; &lt;OF&gt; DataName() | &lt;LENGTH&gt; &lt;OF&gt; Identifier() | &lt;DEBUG_LINE&gt; | &lt;DEBUG_NAME&gt; | &lt;DEBUG_CONTENTS&gt; | &lt;DEBUG_ITEM&gt; | &lt;DEBUG_SUB_1&gt; | &lt;DEBUG_SUB_2&gt; | &lt;DEBUG_SUB_3&gt; | &lt;RETURN_CODE&gt; | &lt;SHIFT_OUT&gt; | &lt;SHIFT_IN&gt; | &lt;SORT_CONTROL&gt; | &lt;SORT_CORE_SIZE&gt; | &lt;SORT_FILE_SIZE&gt; | &lt;SORT_MESSAGE&gt; | &lt;SORT_MODE_SIZE&gt; | &lt;SORT_RETURN&gt; | &lt;TALLY&gt; | &lt;WHEN_COMPILED&gt; )
    * </PRE>
    */
   public void visit(SpecialRegister n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * timesDiv -> TimesDiv()
    * nodeListOptional -> ( ( ( &lt;PLUSCHAR_SUBS&gt; | &lt;PLUSCHAR&gt; ) | ( &lt;MINUSCHAR_SUBS&gt; | &lt;MINUSCHAR&gt; ) ) TimesDiv() )*
    * </PRE>
    */
   public void visit(ArithmeticExpression n) {
      n.timesDiv.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * power -> Power()
    * nodeListOptional -> ( ( &lt;ASTERISKCHAR&gt; | &lt;SLASHCHAR&gt; ) Power() )*
    * </PRE>
    */
   public void visit(TimesDiv n) {
      n.power.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeOptional -> [ ( ( &lt;PLUSCHAR_SUBS&gt; | &lt;PLUSCHAR&gt; ) | ( &lt;MINUSCHAR_SUBS&gt; | &lt;MINUSCHAR&gt; ) ) ]
    * basis -> Basis()
    * nodeListOptional -> ( &lt;POW&gt; Basis() )*
    * </PRE>
    */
   public void visit(Power n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.basis.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( Identifier() | Literal() | &lt;LPARENCHAR&gt; ArithmeticExpression() &lt;RPARENCHAR&gt; )
    * </PRE>
    */
   public void visit(Basis n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeList -> ( &lt;COMMENT2&gt; [ &lt;DOT2&gt; ] )+
    * </PRE>
    */
   public void visit(CommentLine n) {
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeListOptional -> ( ProgramUnit() ( NestedProgramUnit() )* [ EndProgramStatement() ] )*
    * nodeToken -> &lt;EOF&gt;
    * </PRE>
    */
   public void visit(CompilationUnit n) {
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * identificationDivision -> IdentificationDivision()
    * nodeOptional -> [ EnvironmentDivision() ]
    * nodeOptional1 -> [ DataDivision() ]
    * nodeOptional2 -> [ ProcedureDivision() ]
    * </PRE>
    */
   public void visit(ProgramUnit n) {
      n.identificationDivision.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nestedIdentificationDivision -> NestedIdentificationDivision()
    * nodeOptional -> [ EnvironmentDivision() ]
    * nodeOptional1 -> [ DataDivision() ]
    * nodeOptional2 -> [ ProcedureDivision() ]
    * nodeListOptional -> ( NestedProgramUnit() )*
    * endProgramStatement -> EndProgramStatement()
    * </PRE>
    */
   public void visit(NestedProgramUnit n) {
      n.nestedIdentificationDivision.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      n.endProgramStatement.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;END&gt;
    * nodeToken1 -> &lt;PROGRAM&gt;
    * programName -> ProgramName()
    * nodeToken2 -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(EndProgramStatement n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.programName.accept(this);
      n.nodeToken2.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;IDENTIFICATION&gt;
    * nodeToken1 -> &lt;DIVISION&gt;
    * nodeToken2 -> &lt;DOT&gt;
    * programIdParagraph -> ProgramIdParagraph()
    * nodeListOptional -> ( IdentificationDivisionParagraph() )*
    * </PRE>
    */
   public void visit(IdentificationDivision n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.nodeToken2.accept(this);
      n.programIdParagraph.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;IDENTIFICATION&gt; | &lt;ID&gt; )
    * nodeToken -> &lt;DIVISION&gt;
    * nodeToken1 -> &lt;DOT&gt;
    * nestedProgramIdParagraph -> NestedProgramIdParagraph()
    * nodeListOptional -> ( IdentificationDivisionParagraph() )*
    * </PRE>
    */
   public void visit(NestedIdentificationDivision n) {
      n.nodeChoice.accept(this);
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.nestedProgramIdParagraph.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> AuthorParagraph()
    *       | InstallationParagraph()
    *       | DateWrittenParagraph()
    *       | DateCompiledParagraph()
    *       | SecurityParagraph()
    * </PRE>
    */
   public void visit(IdentificationDivisionParagraph n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;PROGRAM_ID&gt;
    * nodeToken1 -> &lt;DOT&gt;
    * programName -> ProgramName()
    * nodeOptional -> [ [ &lt;IS&gt; ] &lt;INITIAL&gt; [ &lt;PROGRAM&gt; ] ]
    * nodeToken2 -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(ProgramIdParagraph n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.programName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken2.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;PROGRAM_ID&gt;
    * nodeToken1 -> &lt;DOT&gt;
    * programName -> ProgramName()
    * nodeOptional -> [ [ &lt;IS&gt; ] InitialOrCommon() [ &lt;PROGRAM&gt; ] ]
    * nodeToken2 -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(NestedProgramIdParagraph n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.programName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken2.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;INITIAL&gt; [ &lt;COMMON&gt; ] | &lt;COMMON&gt; [ &lt;INITIAL&gt; ] )
    * </PRE>
    */
   public void visit(InitialOrCommon n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;AUTHOR&gt; | &lt;AUTHOR2&gt; )
    * nodeChoice1 -> ( &lt;DOT2&gt; | &lt;DOT&gt; )
    * nodeOptional -> [ CommentLine() ]
    * </PRE>
    */
   public void visit(AuthorParagraph n) {
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;INSTALLATION&gt; | &lt;INSTALLATION2&gt; )
    * nodeChoice1 -> ( &lt;DOT2&gt; | &lt;DOT&gt; )
    * nodeOptional -> [ CommentLine() ]
    * </PRE>
    */
   public void visit(InstallationParagraph n) {
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;DATE_WRITTEN&gt; | &lt;DATE_WRITTEN2&gt; )
    * nodeChoice1 -> ( &lt;DOT2&gt; | &lt;DOT&gt; )
    * nodeOptional -> [ CommentLine() ]
    * </PRE>
    */
   public void visit(DateWrittenParagraph n) {
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;DATE_COMPILED&gt; | &lt;DATE_COMPILED2&gt; )
    * nodeChoice1 -> ( &lt;DOT2&gt; | &lt;DOT&gt; )
    * nodeOptional -> [ CommentLine() ]
    * </PRE>
    */
   public void visit(DateCompiledParagraph n) {
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;SECURITY&gt; | &lt;SECURITY2&gt; )
    * nodeChoice1 -> ( &lt;DOT2&gt; | &lt;DOT&gt; )
    * nodeOptional -> [ CommentLine() ]
    * </PRE>
    */
   public void visit(SecurityParagraph n) {
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;ENVIRONMENT&gt; &lt;DIVISION&gt; &lt;DOT&gt; | &lt;ENVIRONMENT_DIVISION&gt; )
    * nodeListOptional -> ( EnvironmentSection() )*
    * </PRE>
    */
   public void visit(EnvironmentDivision n) {
      n.nodeChoice.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ConfigurationSection()
    *       | InputOutputSection()
    * </PRE>
    */
   public void visit(EnvironmentSection n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CONFIGURATION&gt;
    * nodeToken1 -> &lt;SECTION&gt;
    * nodeToken2 -> &lt;DOT&gt;
    * nodeListOptional -> ( ConfigurationSectionParagraph() )*
    * </PRE>
    */
   public void visit(ConfigurationSection n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.nodeToken2.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> SourceComputerParagraph()
    *       | ObjectComputerParagraph()
    *       | SpecialNamesParagraph()
    * </PRE>
    */
   public void visit(ConfigurationSectionParagraph n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SOURCE_COMPUTER&gt;
    * nodeToken1 -> &lt;DOT&gt;
    * computerName -> ComputerName()
    * nodeOptional -> [ [ &lt;WITH&gt; ] &lt;DEBUGGING&gt; &lt;MODE&gt; ]
    * nodeToken2 -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(SourceComputerParagraph n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.computerName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken2.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;OBJECT_COMPUTER&gt;
    * nodeToken1 -> &lt;DOT&gt;
    * computerName -> ComputerName()
    * nodeListOptional -> ( ObjectComputerClause() )*
    * nodeToken2 -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(ObjectComputerParagraph n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.computerName.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      n.nodeToken2.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> MemorySizeClause()
    *       | CollatingSequenceClause()
    *       | SegmentLimitClause()
    *       | CharacterSetClause()
    * </PRE>
    */
   public void visit(ObjectComputerClause n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;MEMORY&gt;
    * nodeOptional -> [ &lt;SIZE&gt; ]
    * integerConstant -> IntegerConstant()
    * nodeOptional1 -> [ &lt;WORDS&gt; | &lt;CHARACTERS&gt; | &lt;MODULES&gt; ]
    * </PRE>
    */
   public void visit(MemorySizeClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.integerConstant.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;PROGRAM&gt; ]
    * nodeOptional1 -> [ &lt;COLLATING&gt; ]
    * nodeToken -> &lt;SEQUENCE&gt;
    * nodeOptional2 -> [ &lt;IS&gt; ]
    * alphabetName -> AlphabetName()
    * </PRE>
    */
   public void visit(CollatingSequenceClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeToken.accept(this);
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      n.alphabetName.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SEGMENT_LIMIT&gt;
    * nodeOptional -> [ &lt;IS&gt; ]
    * integerConstant -> IntegerConstant()
    * </PRE>
    */
   public void visit(SegmentLimitClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.integerConstant.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CHARACTER&gt;
    * nodeToken1 -> &lt;SET&gt;
    * </PRE>
    */
   public void visit(CharacterSetClause n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SPECIAL_NAMES&gt;
    * nodeToken1 -> &lt;DOT&gt;
    * nodeOptional -> [ SpecialNameClause() ( [ &lt;COMMACHAR&gt; ] SpecialNameClause() )* &lt;DOT&gt; ]
    * </PRE>
    */
   public void visit(SpecialNamesParagraph n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> AlphabetClause()
    *       | ClassClause()
    *       | CurrencySignClause()
    *       | DecimalPointClause()
    *       | SymbolicCharactersClause()
    *       | EnvironmentNameIsMnemonicNameClause()
    * </PRE>
    */
   public void visit(SpecialNameClause n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;ALPHABET&gt;
    * alphabetName -> AlphabetName()
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeChoice -> ( &lt;STANDARD_1&gt; | &lt;STANDARD_2&gt; | &lt;NATIVE&gt; | CobolWord() | ( Literal() [ ( ( &lt;THROUGH&gt; | &lt;THRU&gt; ) Literal() | ( &lt;ALSO&gt; Literal() [ &lt;COMMACHAR&gt; ] )+ ) ] [ &lt;COMMACHAR&gt; ] )+ )
    * </PRE>
    */
   public void visit(AlphabetClause n) {
      n.nodeToken.accept(this);
      n.alphabetName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CLASS&gt;
    * className -> ClassName()
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeList -> ( Literal() [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) Literal() ] )+
    * </PRE>
    */
   public void visit(ClassClause n) {
      n.nodeToken.accept(this);
      n.className.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CURRENCY&gt;
    * nodeOptional -> [ &lt;SIGN&gt; ]
    * nodeOptional1 -> [ &lt;IS&gt; ]
    * literal -> Literal()
    * </PRE>
    */
   public void visit(CurrencySignClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.literal.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;DECIMAL_POINT&gt;
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeToken1 -> &lt;COMMA&gt;
    * </PRE>
    */
   public void visit(DecimalPointClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SYMBOLIC&gt;
    * nodeOptional -> [ &lt;CHARACTERS&gt; ]
    * nodeList -> ( ( SymbolicCharacter() )+ [ ( &lt;ARE&gt; | &lt;IS&gt; ) ] ( IntegerConstant() )+ )+
    * nodeOptional1 -> [ &lt;IN&gt; AlphabetName() ]
    * </PRE>
    */
   public void visit(SymbolicCharactersClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      processList(n.nodeList);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( EnvironmentName() [ &lt;IS&gt; ] MnemonicName() [ SpecialNamesParagraphStatusPhrase() ] | SpecialNamesParagraphStatusPhrase() )
    * </PRE>
    */
   public void visit(EnvironmentNameIsMnemonicNameClause n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;ON&gt; [ &lt;STATUS&gt; ] [ &lt;IS&gt; ] Condition() [ &lt;OFF&gt; [ &lt;STATUS&gt; ] [ &lt;IS&gt; ] Condition() ] | &lt;OFF&gt; [ &lt;STATUS&gt; ] [ &lt;IS&gt; ] Condition() [ &lt;ON&gt; [ &lt;STATUS&gt; ] [ &lt;IS&gt; ] Condition() ] )
    * </PRE>
    */
   public void visit(SpecialNamesParagraphStatusPhrase n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;INPUT_OUTPUT&gt; &lt;SECTION&gt; &lt;DOT&gt; ]
    * nodeList -> ( InputOutputSectionParagraph() )+
    * </PRE>
    */
   public void visit(InputOutputSection n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> FileControlParagraph()
    *       | IOControlParagraph()
    * </PRE>
    */
   public void visit(InputOutputSectionParagraph n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;FILE_CONTROL&gt; &lt;DOT&gt; | FileControlEntry() &lt;DOT&gt; )
    * nodeListOptional -> ( FileControlEntry() &lt;DOT&gt; )*
    * </PRE>
    */
   public void visit(FileControlParagraph n) {
      n.nodeChoice.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * selectClause -> SelectClause()
    * nodeListOptional -> ( FileControlClause() )*
    * </PRE>
    */
   public void visit(FileControlEntry n) {
      n.selectClause.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> AssignClause()
    *       | ReserveClause()
    *       | KeyClause()
    *       | OrganizationClause()
    *       | PaddingCharacterClause()
    *       | RecordDelimiterClause()
    *       | AccessModeClause()
    *       | AlternateRecordKeyClause()
    *       | FileStatusClause()
    *       | PasswordClause()
    * </PRE>
    */
   public void visit(FileControlClause n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SELECT&gt;
    * nodeOptional -> [ &lt;OPTIONAL&gt; ]
    * fileName -> FileName()
    * </PRE>
    */
   public void visit(SelectClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.fileName.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;ASSIGN&gt;
    * nodeOptional -> [ &lt;TO&gt; ]
    * nodeOptional1 -> [ &lt;DISK&gt; ]
    * nodeChoice -> ( AssignmentName() | Literal() )
    * </PRE>
    */
   public void visit(AssignClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RESERVE&gt;
    * integerConstant -> IntegerConstant()
    * nodeOptional -> ( &lt;AREA&gt; | &lt;AREAS&gt; )?
    * </PRE>
    */
   public void visit(ReserveClause n) {
      n.nodeToken.accept(this);
      n.integerConstant.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;ORGANIZATION&gt; ]
    * nodeOptional1 -> [ &lt;IS&gt; ]
    * nodeChoice -> ( SequentialOrganizationClause() | IndexedOrganizationClause() | RelativeOrganizationClause() | LineSequentialOrganizationClause() )
    * </PRE>
    */
   public void visit(OrganizationClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SEQUENTIAL&gt;
    * </PRE>
    */
   public void visit(SequentialOrganizationClause n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;LINE&gt;
    * nodeToken1 -> &lt;SEQUENTIAL&gt;
    * </PRE>
    */
   public void visit(LineSequentialOrganizationClause n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RELATIVE&gt;
    * </PRE>
    */
   public void visit(RelativeOrganizationClause n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;INDEXED&gt;
    * </PRE>
    */
   public void visit(IndexedOrganizationClause n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;PADDING&gt;
    * nodeOptional -> [ &lt;CHARACTER&gt; ]
    * nodeOptional1 -> [ &lt;IS&gt; ]
    * nodeChoice -> ( QualifiedDataName() | Literal() )
    * </PRE>
    */
   public void visit(PaddingCharacterClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RECORD&gt;
    * nodeToken1 -> &lt;DELIMITER&gt;
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeChoice -> ( &lt;STANDARD_1&gt; | &lt;IMPLICIT&gt; | AssignmentName() )
    * </PRE>
    */
   public void visit(RecordDelimiterClause n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;ACCESS&gt;
    * nodeOptional -> [ &lt;MODE&gt; ]
    * nodeOptional1 -> [ &lt;IS&gt; ]
    * nodeChoice -> ( SequentialAccessMode() | RandomAccessMode() | DynamicAccessMode() )
    * </PRE>
    */
   public void visit(AccessModeClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SEQUENTIAL&gt;
    * </PRE>
    */
   public void visit(SequentialAccessMode n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RANDOM&gt;
    * </PRE>
    */
   public void visit(RandomAccessMode n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;DYNAMIC&gt;
    * </PRE>
    */
   public void visit(DynamicAccessMode n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;RELATIVE&gt; | &lt;RECORD&gt; )
    * nodeOptional -> [ &lt;KEY&gt; ]
    * nodeOptional1 -> [ &lt;IS&gt; ]
    * qualifiedDataName -> QualifiedDataName()
    * </PRE>
    */
   public void visit(KeyClause n) {
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.qualifiedDataName.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;ALTERNATE&gt;
    * nodeToken1 -> &lt;RECORD&gt;
    * nodeOptional -> [ &lt;KEY&gt; ]
    * nodeOptional1 -> [ &lt;IS&gt; ]
    * qualifiedDataName -> QualifiedDataName()
    * nodeOptional2 -> [ PasswordClause() ]
    * nodeOptional3 -> [ [ &lt;WITH&gt; ] &lt;DUPLICATES&gt; ]
    * </PRE>
    */
   public void visit(AlternateRecordKeyClause n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.qualifiedDataName.accept(this);
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;PASSWORD&gt;
    * nodeOptional -> [ &lt;IS&gt; ]
    * dataName -> DataName()
    * </PRE>
    */
   public void visit(PasswordClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.dataName.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;FILE&gt; ]
    * nodeToken -> &lt;STATUS&gt;
    * nodeOptional1 -> [ &lt;IS&gt; ]
    * qualifiedDataName -> QualifiedDataName()
    * nodeOptional2 -> [ QualifiedDataName() ]
    * </PRE>
    */
   public void visit(FileStatusClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.qualifiedDataName.accept(this);
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;I_O_CONTROL&gt;
    * nodeToken1 -> &lt;DOT&gt;
    * nodeOptional -> [ IOControlClause() ( [ &lt;DOT&gt; ] IOControlClause() )* &lt;DOT&gt; ]
    * </PRE>
    */
   public void visit(IOControlParagraph n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;COMMACHAR&gt; ]
    * nodeChoice -> ( RerunClause() | SameAreaClause() | MultipleFileClause() )
    * nodeOptional1 -> [ &lt;COMMACHAR&gt; ]
    * </PRE>
    */
   public void visit(IOControlClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RERUN&gt;
    * nodeOptional -> [ &lt;ON&gt; ( AssignmentName() | FileName() ) ]
    * nodeToken1 -> &lt;EVERY&gt;
    * nodeChoice -> ( Rerun2() | IntegerConstant() [ &lt;CLOCK_UNITS&gt; ] )
    * </PRE>
    */
   public void visit(RerunClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> IntegerConstant() &lt;RECORDS&gt;
    *       | [ &lt;END&gt; ] [ &lt;OF&gt; ] ( &lt;REEL&gt; | &lt;UNIT&gt; ) &lt;OF&gt; FileName()
    * </PRE>
    */
   public void visit(Rerun2 n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SAME&gt;
    * nodeOptional -> [ &lt;RECORD&gt; | &lt;SORT&gt; | &lt;SORT_MERGE&gt; ]
    * nodeOptional1 -> [ &lt;AREA&gt; ]
    * nodeOptional2 -> [ &lt;FOR&gt; ]
    * nodeList -> ( FileName() [ &lt;COMMACHAR&gt; ] )+
    * </PRE>
    */
   public void visit(SameAreaClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;MULTIPLE&gt;
    * nodeToken1 -> &lt;FILE&gt;
    * nodeOptional -> [ &lt;TAPE&gt; ]
    * nodeOptional1 -> [ &lt;CONTAINS&gt; ]
    * nodeList -> ( FileName() [ &lt;POSITION&gt; ] [ IntegerConstant() ] [ &lt;COMMACHAR&gt; ] )+
    * </PRE>
    */
   public void visit(MultipleFileClause n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;DATA&gt; &lt;DIVISION&gt; &lt;DOT&gt; | &lt;DATA_DIVISION&gt; )
    * nodeListOptional -> ( DataDivisionSection() )*
    * </PRE>
    */
   public void visit(DataDivision n) {
      n.nodeChoice.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> FileSection()
    *       | WorkingStorageSection()
    *       | LinkageSection()
    *       | CommunicationSection()
    * </PRE>
    */
   public void visit(DataDivisionSection n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;COMMUNICATION&gt;
    * nodeToken1 -> &lt;SECTION&gt;
    * nodeToken2 -> &lt;DOT&gt;
    * nodeListOptional -> ( CommunicationDescriptionEntry() ( DataDescriptionEntry() )* )*
    * </PRE>
    */
   public void visit(CommunicationSection n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.nodeToken2.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( CommunicationInputEntry() | CommunicationOutputEntry() | CommunicationIOEntry() )
    * nodeToken -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(CommunicationDescriptionEntry n) {
      n.nodeChoice.accept(this);
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CD&gt;
    * cdName -> CdName()
    * nodeOptional -> [ &lt;FOR&gt; ]
    * nodeOptional1 -> [ &lt;INITIAL&gt; ]
    * nodeToken1 -> &lt;INPUT&gt;
    * nodeListOptional -> ( CommunicationInputClause() )*
    * nodeListOptional1 -> ( DataName() | &lt;FILLER&gt; )*
    * </PRE>
    */
   public void visit(CommunicationInputEntry n) {
      n.nodeToken.accept(this);
      n.cdName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeToken1.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      if ( n.nodeListOptional1.present() ) {
         processList(n.nodeListOptional1);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CD&gt;
    * cdName -> CdName()
    * nodeOptional -> [ &lt;FOR&gt; ]
    * nodeToken1 -> &lt;OUTPUT&gt;
    * nodeListOptional -> ( CommunicationOutputClause() )*
    * </PRE>
    */
   public void visit(CommunicationOutputEntry n) {
      n.nodeToken.accept(this);
      n.cdName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CD&gt;
    * cdName -> CdName()
    * nodeOptional -> [ &lt;FOR&gt; ]
    * nodeOptional1 -> [ &lt;INITIAL&gt; ]
    * nodeToken1 -> &lt;I_O&gt;
    * nodeListOptional -> ( CommunicationIOClause() )*
    * nodeListOptional1 -> ( DataName() | &lt;FILLER&gt; )*
    * </PRE>
    */
   public void visit(CommunicationIOEntry n) {
      n.nodeToken.accept(this);
      n.cdName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeToken1.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      if ( n.nodeListOptional1.present() ) {
         processList(n.nodeListOptional1);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;MESSAGE&gt; ( &lt;DATE&gt; | &lt;TIME&gt; | &lt;COUNT&gt; ) [ &lt;IS&gt; ] DataName()
    *       | &lt;TEXT&gt; &lt;LENGTH&gt; [ &lt;IS&gt; ] DataName()
    *       | &lt;END&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
    *       | &lt;STATUS&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
    *       | &lt;COUNT&gt; [ &lt;IS&gt; ] DataName()
    *       | [ &lt;SYMBOLIC&gt; ] ( &lt;QUEUE&gt; | &lt;SUB_QUEUE_1&gt; | &lt;SUB_QUEUE_2&gt; | &lt;SUB_QUEUE_3&gt; | &lt;SOURCE&gt; ) [ &lt;IS&gt; ] DataName()
    * </PRE>
    */
   public void visit(CommunicationInputClause n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;DESTINATION&gt; &lt;COUNT&gt; [ &lt;IS&gt; ] DataName()
    *       | &lt;TEXT&gt; &lt;LENGTH&gt; [ &lt;IS&gt; ] DataName()
    *       | &lt;STATUS&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
    *       | [ &lt;SYMBOLIC&gt; ] &lt;DESTINATION&gt; [ &lt;IS&gt; ] DataName()
    *       | &lt;DESTINATION&gt; &lt;TABLE&gt; &lt;OCCURS&gt; IntegerConstant() [ &lt;TIMES&gt; ] [ &lt;INDEXED&gt; [ &lt;BY&gt; ] ( IndexName() [ &lt;COMMACHAR&gt; ] )+ ]
    *       | &lt;ERROR&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
    * </PRE>
    */
   public void visit(CommunicationOutputClause n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;MESSAGE&gt; ( &lt;DATE&gt; | &lt;TIME&gt; ) [ &lt;IS&gt; ] DataName()
    *       | &lt;TEXT&gt; &lt;LENGTH&gt; [ &lt;IS&gt; ] DataName()
    *       | &lt;END&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
    *       | &lt;STATUS&gt; &lt;KEY&gt; [ &lt;IS&gt; ] DataName()
    *       | [ &lt;SYMBOLIC&gt; ] &lt;TERMINAL&gt; [ &lt;IS&gt; ] DataName()
    * </PRE>
    */
   public void visit(CommunicationIOClause n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( ( &lt;FILE&gt; &lt;SECTION&gt; &lt;DOT&gt; ) | ( FileAndSortDescriptionEntry() ( DataDescriptionEntry() )+ ) )
    * nodeListOptional -> ( FileAndSortDescriptionEntry() ( DataDescriptionEntry() )+ )*
    * </PRE>
    */
   public void visit(FileSection n) {
      n.nodeChoice.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;FD&gt; | &lt;SD&gt; )
    * fileName -> FileName()
    * nodeListOptional -> ( FileAndSortDescriptionEntryClause() )*
    * nodeToken -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(FileAndSortDescriptionEntry n) {
      n.nodeChoice.accept(this);
      n.fileName.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ExternalClause()
    *       | GlobalClause()
    *       | BlockContainsClause()
    *       | RecordContainsClause()
    *       | LabelRecordsClause()
    *       | ValueOfClause()
    *       | DataRecordClause()
    *       | LinageClause()
    *       | CodeSetClause()
    *       | ReportClause()
    *       | RecordingModeClause()
    * </PRE>
    */
   public void visit(FileAndSortDescriptionEntryClause n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeToken -> &lt;EXTERNAL&gt;
    * </PRE>
    */
   public void visit(ExternalClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeToken -> &lt;GLOBAL&gt;
    * </PRE>
    */
   public void visit(GlobalClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;BLOCK&gt;
    * nodeOptional -> [ &lt;CONTAINS&gt; ]
    * nodeOptional1 -> [ IntegerConstant() &lt;TO&gt; ]
    * integerConstant -> IntegerConstant()
    * nodeOptional2 -> [ &lt;RECORDS&gt; | &lt;CHARACTERS&gt; ]
    * </PRE>
    */
   public void visit(BlockContainsClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.integerConstant.accept(this);
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RECORD&gt;
    * nodeOptional -> [ &lt;CONTAINS&gt; ]
    * nodeChoice -> ( [ IntegerConstant() &lt;TO&gt; ] IntegerConstant() [ &lt;CHARACTERS&gt; ] | [ &lt;IS&gt; ] &lt;VARYING&gt; [ &lt;IN&gt; ] [ &lt;SIZE&gt; ] [ [ &lt;FROM&gt; ] IntegerConstant() [ &lt;TO&gt; IntegerConstant() ] [ &lt;CHARACTERS&gt; ] ] [ &lt;DEPENDING&gt; [ &lt;ON&gt; ] QualifiedDataName() ] )
    * </PRE>
    */
   public void visit(RecordContainsClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;LABEL&gt;
    * nodeChoice -> ( &lt;RECORD&gt; [ &lt;IS&gt; ] | &lt;RECORDS&gt; [ &lt;ARE&gt; ] )
    * nodeChoice1 -> ( &lt;OMITTED&gt; | &lt;STANDARD&gt; | ( DataName() )+ )
    * </PRE>
    */
   public void visit(LabelRecordsClause n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;VALUE&gt;
    * nodeToken1 -> &lt;OF&gt;
    * nodeList -> ( SystemName() &lt;IS&gt; ( QualifiedDataName() | Literal() ) )+
    * </PRE>
    */
   public void visit(ValueOfClause n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;DATA&gt;
    * nodeChoice -> ( &lt;RECORD&gt; [ &lt;IS&gt; ] | &lt;RECORDS&gt; [ &lt;ARE&gt; ] )
    * nodeList -> ( DataName() [ &lt;COMMACHAR&gt; ] )+
    * </PRE>
    */
   public void visit(DataRecordClause n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;LINAGE&gt;
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeChoice -> ( DataName() | IntegerConstant() )
    * nodeOptional1 -> [ &lt;LINES&gt; ]
    * nodeListOptional -> ( [ &lt;WITH&gt; ] &lt;FOOTING&gt; [ &lt;AT&gt; ] ( DataName() | IntegerConstant() ) | [ &lt;LINES&gt; ] [ &lt;AT&gt; ] &lt;TOP&gt; ( DataName() | IntegerConstant() ) | [ &lt;LINES&gt; ] [ &lt;AT&gt; ] &lt;BOTTOM&gt; ( DataName() | IntegerConstant() ) )*
    * </PRE>
    */
   public void visit(LinageClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RECORDING&gt;
    * nodeOptional -> [ &lt;MODE&gt; ]
    * nodeOptional1 -> [ &lt;IS&gt; ]
    * mode -> Mode()
    * </PRE>
    */
   public void visit(RecordingModeClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.mode.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CODE_SET&gt;
    * nodeOptional -> [ &lt;IS&gt; ]
    * alphabetName -> AlphabetName()
    * </PRE>
    */
   public void visit(CodeSetClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.alphabetName.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;REPORT&gt; [ &lt;IS&gt; ] | &lt;REPORTS&gt; [ &lt;ARE&gt; ] )
    * nodeList -> ( QualifiedDataName() )+
    * </PRE>
    */
   public void visit(ReportClause n) {
      n.nodeChoice.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> ( LevelNumber() ( DataName() | &lt;FILLER&gt; )? ( DataDescriptionEntryClause() )* &lt;DOT&gt; | &lt;LEVEL_66&gt; DataName() RenamesClause() &lt;DOT&gt; | &lt;LEVEL_77&gt; DataName() ( DataDescriptionEntryClause() )* &lt;DOT&gt; | &lt;LEVEL_78&gt; ConditionName() ConditionValueClause() &lt;DOT&gt; | &lt;LEVEL_88&gt; ConditionName() ConditionValueClause() &lt;DOT&gt; | ( &lt;EXEC&gt; | &lt;EXECUTE&gt; ) &lt;K_SQL&gt; ( &lt;K_INCLUDE&gt; ( &lt;S_IDENTIFIER&gt; | &lt;S_QUOTED_IDENTIFIER&gt; ) &lt;DOT&gt; | &lt;K_BEGIN&gt; &lt;K_DECLARE&gt; &lt;K_SECTION&gt; &lt;END_EXEC&gt; &lt;DOT&gt; | &lt;K_END&gt; &lt;K_DECLARE&gt; &lt;K_SECTION&gt; &lt;END_EXEC&gt; &lt;DOT&gt; | DeclareCursorStatement() &lt;END_EXEC&gt; &lt;DOT&gt; ) )
    * </PRE>
    */
   public void visit(DataDescriptionEntry n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;COMMACHAR&gt; ]
    * nodeChoice -> ( DataPictureClause() | DataValueClause() | DataUsageClause() | DataRedefinesClause() | DataExternalClause() | DataGlobalClause() | DataSignClause() | DataOccursClause() | DataSynchronizedClause() | DataJustifiedClause() | DataBlankWhenZeroClause() )
    * nodeOptional1 -> [ &lt;COMMACHAR&gt; ]
    * </PRE>
    */
   public void visit(DataDescriptionEntryClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;REDEFINES&gt;
    * dataName -> DataName()
    * </PRE>
    */
   public void visit(DataRedefinesClause n) {
      n.nodeToken.accept(this);
      n.dataName.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;BLANK&gt;
    * nodeOptional -> [ &lt;WHEN&gt; ]
    * nodeChoice -> ( &lt;ZERO&gt; | &lt;ZEROS&gt; | &lt;ZEROES&gt; )
    * </PRE>
    */
   public void visit(DataBlankWhenZeroClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;JUSTIFIED&gt; | &lt;JUST&gt; )
    * nodeOptional -> [ &lt;RIGHT&gt; ]
    * </PRE>
    */
   public void visit(DataJustifiedClause n) {
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;OCCURS&gt;
    * nodeOptional -> [ ( IntegerConstant() | DataName() ) &lt;TO&gt; ]
    * nodeChoice -> ( IntegerConstant() | DataName() )
    * nodeOptional1 -> [ &lt;TIMES&gt; ]
    * nodeOptional2 -> [ &lt;DEPENDING&gt; [ &lt;ON&gt; ] QualifiedDataName() ]
    * nodeListOptional -> ( ( &lt;ASCENDING&gt; | &lt;DESCENDING&gt; ) [ &lt;KEY&gt; ] [ &lt;IS&gt; ] ( QualifiedDataName() )+ )*
    * nodeOptional3 -> [ &lt;INDEXED&gt; [ &lt;BY&gt; ] ( IndexName() [ &lt;COMMACHAR&gt; ] )+ ]
    * </PRE>
    */
   public void visit(DataOccursClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;PICTURE&gt; | &lt;PIC&gt; )
    * nodeOptional -> [ &lt;IS&gt; ]
    * pictureString -> PictureString()
    * nodeOptional1 -> [ &lt;VARYING&gt; ]
    * </PRE>
    */
   public void visit(DataPictureClause n) {
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.pictureString.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * pictureOccurence -> PictureOccurence()
    * nodeListOptional -> ( &lt;DOTCHAR&gt; PictureOccurence() | PictureOccurence() )*
    * nodeListOptional1 -> ( &lt;DOTCHAR&gt; )*
    * </PRE>
    */
   public void visit(PictureString n) {
      n.pictureOccurence.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      if ( n.nodeListOptional1.present() ) {
         processList(n.nodeListOptional1);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( NonDotChars() )+ [ &lt;LPARENCHAR&gt; ( IntegerConstant() | DataName() ) &lt;RPARENCHAR&gt; ]
    *       | &lt;DOTCHAR&gt; ( &lt;LPARENCHAR&gt; ( IntegerConstant() | DataName() ) &lt;RPARENCHAR&gt; | NonDotChars() )
    * </PRE>
    */
   public void visit(PictureOccurence n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;SLASHCHAR&gt;
    *       | &lt;COMMACHAR&gt;
    *       | &lt;COLONCHAR&gt;
    *       | &lt;ASTERISKCHAR&gt;
    *       | &lt;MINUSCHAR&gt;
    *       | &lt;PLUSCHAR&gt;
    *       | &lt;POW&gt;
    *       | &lt;LESSTHANOREQUAL&gt;
    *       | &lt;LESSTHANCHAR&gt;
    *       | &lt;MORETHANOREQUAL&gt;
    *       | &lt;MORETHANCHAR&gt;
    *       | &lt;EQUALCHAR&gt;
    *       | &lt;NOTEQUALCHAR&gt;
    * </PRE>
    */
   public void visit(PicturePunctuation n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;DOLLARCHAR&gt;
    * </PRE>
    */
   public void visit(PictureCurrency n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> IntegerConstant()
    *       | CobolWord()
    *       | PicturePunctuation()
    *       | PictureCurrency()
    * </PRE>
    */
   public void visit(NonDotChars n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeToken -> &lt;EXTERNAL&gt;
    * </PRE>
    */
   public void visit(DataExternalClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;IS&gt; ]
    * nodeToken -> &lt;GLOBAL&gt;
    * </PRE>
    */
   public void visit(DataGlobalClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;USAGE&gt; [ &lt;IS&gt; ] ]
    * nodeChoice -> ( &lt;BINARY&gt; | &lt;COMP&gt; | &lt;COMP_1&gt; | &lt;COMP_2&gt; | &lt;COMP_3&gt; | &lt;COMP_4&gt; | &lt;COMP_5&gt; | &lt;COMPUTATIONAL&gt; | &lt;COMPUTATIONAL_1&gt; | &lt;COMPUTATIONAL_2&gt; | &lt;COMPUTATIONAL_3&gt; | &lt;COMPUTATIONAL_4&gt; | &lt;COMPUTATIONAL_5&gt; | &lt;DISPLAY&gt; | &lt;DISPLAY_1&gt; | &lt;INDEX&gt; | &lt;PACKED_DECIMAL&gt; | &lt;POINTER&gt; | &lt;FUNCTION_POINTER&gt; | &lt;PROCEDURE_POINTER&gt; | &lt;OBJECT&gt; &lt;REFERENCE&gt; DataName() )
    * </PRE>
    */
   public void visit(DataUsageClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;SIGN&gt; [ &lt;IS&gt; ] ]
    * nodeChoice -> ( &lt;LEADING&gt; | &lt;TRAILING&gt; )
    * nodeOptional1 -> [ &lt;SEPARATE&gt; [ &lt;CHARACTER&gt; ] ]
    * </PRE>
    */
   public void visit(DataSignClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;SYNCHRONIZED&gt; | &lt;SYNC&gt; )
    * nodeOptional -> [ ( &lt;LEFT&gt; | &lt;RIGHT&gt; ) ]
    * </PRE>
    */
   public void visit(DataSynchronizedClause n) {
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;VALUE&gt; [ &lt;IS&gt; ] | &lt;VALUES&gt; [ &lt;ARE&gt; ] )
    * nodeList -> ( ( Identifier() | Literal() ) [ &lt;COMMACHAR&gt; ] [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) Literal() [ &lt;COMMACHAR&gt; ] ] )+
    * </PRE>
    */
   public void visit(DataValueClause n) {
      n.nodeChoice.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * dataValueClause -> DataValueClause()
    * </PRE>
    */
   public void visit(ConditionValueClause n) {
      n.dataValueClause.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RENAMES&gt;
    * qualifiedDataName -> QualifiedDataName()
    * nodeOptional -> [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) QualifiedDataName() ]
    * </PRE>
    */
   public void visit(RenamesClause n) {
      n.nodeToken.accept(this);
      n.qualifiedDataName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;WORKING_STORAGE&gt;
    * nodeToken1 -> &lt;SECTION&gt;
    * nodeToken2 -> &lt;DOT&gt;
    * nodeListOptional -> ( DataDescriptionEntry() )*
    * </PRE>
    */
   public void visit(WorkingStorageSection n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.nodeToken2.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;LINKAGE&gt;
    * nodeToken1 -> &lt;SECTION&gt;
    * nodeToken2 -> &lt;DOT&gt;
    * nodeListOptional -> ( DataDescriptionEntry() )*
    * </PRE>
    */
   public void visit(LinkageSection n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.nodeToken2.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;PROCEDURE&gt; &lt;DIVISION&gt; | &lt;PROCEDURE_DIVISION&gt; )
    * nodeOptional -> [ [ &lt;DOT&gt; ] UsingArgs() ]
    * nodeToken -> &lt;DOT&gt;
    * nodeOptional1 -> [ Declaratives() ]
    * procedureBody -> ProcedureBody()
    * </PRE>
    */
   public void visit(ProcedureDivision n) {
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.procedureBody.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;USING&gt;
    * nodeList -> ( [ [ &lt;BY&gt; ] ( &lt;REFERENCE&gt; | &lt;VALUE&gt; ) ] QualifiedDataName() [ &lt;COMMACHAR&gt; ] )+
    * </PRE>
    */
   public void visit(UsingArgs n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;DECLARATIVES&gt;
    * nodeToken1 -> &lt;DOT&gt;
    * nodeList -> ( SectionHeader() &lt;DOT&gt; UseStatement() &lt;DOT&gt; Paragraphs() )+
    * nodeToken2 -> &lt;END&gt;
    * nodeToken3 -> &lt;DECLARATIVES&gt;
    * nodeToken4 -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(Declaratives n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      processList(n.nodeList);
      n.nodeToken2.accept(this);
      n.nodeToken3.accept(this);
      n.nodeToken4.accept(this);
   }

   /**
    * <PRE>
    * paragraphs -> Paragraphs()
    * nodeListOptional -> ( ProcedureSection() )*
    * </PRE>
    */
   public void visit(ProcedureBody n) {
      n.paragraphs.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * sectionHeader -> SectionHeader()
    * nodeToken -> &lt;DOT&gt;
    * paragraphs -> Paragraphs()
    * </PRE>
    */
   public void visit(ProcedureSection n) {
      n.sectionHeader.accept(this);
      n.nodeToken.accept(this);
      n.paragraphs.accept(this);
   }

   /**
    * <PRE>
    * sectionName -> SectionName()
    * nodeToken -> &lt;SECTION&gt;
    * nodeOptional -> [ IntegerConstant() ]
    * </PRE>
    */
   public void visit(SectionHeader n) {
      n.sectionName.accept(this);
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeListOptional -> ( Sentence() )*
    * nodeListOptional1 -> ( Paragraph() )*
    * </PRE>
    */
   public void visit(Paragraphs n) {
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      if ( n.nodeListOptional1.present() ) {
         processList(n.nodeListOptional1);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( ParagraphName() | EntryStatement() )
    * nodeToken -> &lt;DOT&gt;
    * nodeChoice1 -> ( ExitProgramStatement() &lt;DOT&gt; | ExitStatement() &lt;DOT&gt; | AlteredGoto() | ( Sentence() )* )
    * </PRE>
    */
   public void visit(Paragraph n) {
      n.nodeChoice.accept(this);
      n.nodeToken.accept(this);
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * nodeList -> ( Statement() )+
    * nodeToken -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(Sentence n) {
      processList(n.nodeList);
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeList -> ( Statement() )+
    * </PRE>
    */
   public void visit(StatementList n) {
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> ( AcceptStatement() | AddStatement() | AlterStatement() | CallStatement() | CancelStatement() | CloseStatement() | ComputeStatement() | ContinueStatement() | DeleteStatement() | DisplayStatement() | DivideStatement() | EvaluateStatement() | ExitProgramStatement() | ExitStatement() | GobackStatement() | GotoStatement() | IfStatement() | InitializeStatement() | InspectStatement() | MergeStatement() | MoveStatement() | MultiplyStatement() | OpenStatement() | PerformStatement() | ReadStatement() | ReleaseStatement() | ReturnStatement() | RewriteStatement() | SearchStatement() | SetStatement() | SortStatement() | StartStatement() | StopStatement() | StringStatement() | SubtractStatement() | UnstringStatement() | WriteStatement() | ExecSqlStatement() | EnableStatement() | DisableStatement() | ReceiveStatement() | SendStatement() )
    * nodeOptional -> [ &lt;COMMACHAR&gt; ]
    * </PRE>
    */
   public void visit(Statement n) {
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;ENABLE&gt;
    * nodeChoice -> ( &lt;INPUT&gt; [ &lt;TERMINAL&gt; ] | &lt;OUTPUT&gt; )
    * nodeChoice1 -> ( Identifier() | Literal() )
    * nodeOptional -> [ &lt;WITH&gt; ]
    * nodeToken1 -> &lt;KEY&gt;
    * nodeChoice2 -> ( Identifier() | Literal() )
    * </PRE>
    */
   public void visit(EnableStatement n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
      n.nodeChoice2.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;DISABLE&gt;
    * nodeChoice -> ( &lt;INPUT&gt; [ &lt;TERMINAL&gt; ] | &lt;OUTPUT&gt; )
    * nodeChoice1 -> ( Identifier() | Literal() )
    * nodeOptional -> [ &lt;WITH&gt; ]
    * nodeToken1 -> &lt;KEY&gt;
    * nodeChoice2 -> ( Identifier() | Literal() )
    * </PRE>
    */
   public void visit(DisableStatement n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
      n.nodeChoice2.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RECEIVE&gt;
    * nodeChoice -> ( Identifier() | Literal() )
    * nodeChoice1 -> ( &lt;MESSAGE&gt; | &lt;SEGMENT&gt; )
    * nodeToken1 -> &lt;INTO&gt;
    * identifier -> Identifier()
    * nodeOptional -> [ ";" | &lt;NO&gt; &lt;DATA&gt; Statement() ]
    * </PRE>
    */
   public void visit(ReceiveStatement n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
      n.nodeToken1.accept(this);
      n.identifier.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SEND&gt;
    * nodeChoice -> ( Identifier() | Literal() )
    * nodeOptional -> [ &lt;FROM&gt; Identifier() ]
    * nodeOptional1 -> [ &lt;WITH&gt; ( Identifier() | &lt;ESI&gt; | &lt;EMI&gt; | &lt;EGI&gt; ) ]
    * nodeOptional2 -> [ ( &lt;BEFORE&gt; | &lt;AFTER&gt; ) [ &lt;ADVANCING&gt; ] ( ( ( Identifier() | Literal() ) [ &lt;LINE&gt; | &lt;LINES&gt; ] ) | ( MnemonicName() | &lt;PAGE&gt; ) ) ]
    * </PRE>
    */
   public void visit(SendStatement n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;EXEC&gt; | &lt;EXECUTE&gt; )
    * nodeToken -> &lt;K_SQL&gt;
    * nodeChoice1 -> ( &lt;K_WHENEVER&gt; ( &lt;K_NOT&gt; &lt;K_FOUND&gt; | &lt;K_SQLERROR&gt; | &lt;K_SQLWARNING&gt; ) Statement() | ( ( SQLStatement() | DeclareCursorStatement() | &lt;K_PREPARE&gt; &lt;S_IDENTIFIER&gt; &lt;K_FROM&gt; &lt;S_BIND&gt; | &lt;K_ALTER&gt; &lt;K_SESSION&gt; SQLSetStatement() | &lt;K_EXECUTE&gt; SkipToEndExec() | &lt;K_CONNECT&gt; &lt;S_BIND&gt; | SkipToEndExec() ) &lt;END_EXEC&gt; ) )
    * </PRE>
    */
   public void visit(ExecSqlStatement n) {
      n.nodeChoice.accept(this);
      n.nodeToken.accept(this);
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_DECLARE&gt;
    * nodeToken1 -> &lt;S_IDENTIFIER&gt;
    * nodeToken2 -> &lt;K_CURSOR&gt;
    * nodeToken3 -> &lt;K_FOR&gt;
    * nodeChoice -> ( &lt;S_IDENTIFIER&gt; | QueryStatement() )
    * </PRE>
    */
   public void visit(DeclareCursorStatement n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.nodeToken2.accept(this);
      n.nodeToken3.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;ACCEPT&gt;
    * identifier -> Identifier()
    * nodeOptional -> [ &lt;FROM&gt; ( MnemonicName() | EnvironmentName() | &lt;DATE&gt; [ &lt;COBOL_WORD&gt; ] | &lt;DAY&gt; [ &lt;COBOL_WORD&gt; ] | &lt;DAY_OF_WEEK&gt; | &lt;TIME&gt; ) | [ &lt;MESSAGE&gt; ] &lt;COUNT&gt; ]
    * </PRE>
    */
   public void visit(AcceptStatement n) {
      n.nodeToken.accept(this);
      n.identifier.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;ADD&gt;
    * addBody -> AddBody()
    * nodeOptional -> [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional1 -> [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional2 -> [ &lt;END_ADD&gt; ]
    * </PRE>
    */
   public void visit(AddStatement n) {
      n.nodeToken.accept(this);
      n.addBody.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> IdOrLiteralList() [ &lt;TO&gt; IdOrLiteral() ] &lt;GIVING&gt; ArithIdentifierList()
    *       | IdOrLiteralList() &lt;TO&gt; ArithIdentifierList()
    *       | ( &lt;CORRESPONDING&gt; | &lt;CORR&gt; ) Identifier() &lt;TO&gt; Identifier() [ &lt;ROUNDED&gt; ]
    * </PRE>
    */
   public void visit(AddBody n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * identifier -> Identifier()
    * nodeOptional -> [ &lt;ROUNDED&gt; ]
    * </PRE>
    */
   public void visit(ArithIdentifier n) {
      n.identifier.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeList -> ( ArithIdentifier() [ &lt;COMMACHAR&gt; ] )+
    * </PRE>
    */
   public void visit(ArithIdentifierList n) {
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> Identifier()
    *       | Literal()
    * </PRE>
    */
   public void visit(IdOrLiteral n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeList -> ( IdOrLiteral() [ &lt;COMMACHAR&gt; ] )+
    * </PRE>
    */
   public void visit(IdOrLiteralList n) {
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;GO&gt;
    * nodeOptional -> [ &lt;TO&gt; ]
    * nodeToken1 -> &lt;DOT&gt;
    * </PRE>
    */
   public void visit(AlteredGoto n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;ALTER&gt;
    * nodeList -> ( ProcedureName() &lt;TO&gt; [ &lt;PROCEED&gt; &lt;TO&gt; ] ProcedureName() [ &lt;COMMACHAR&gt; ] )+
    * </PRE>
    */
   public void visit(AlterStatement n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CALL&gt;
    * nodeChoice -> ( Identifier() | Literal() )
    * nodeOptional -> [ &lt;USING&gt; ( ( [ [ &lt;BY&gt; ] &lt;REFERENCE&gt; ] ( CallByReferenceArgs() [ &lt;COMMACHAR&gt; ] )+ | [ &lt;BY&gt; ] ( &lt;CONTENT&gt; | &lt;VALUE&gt; ) ( CallByContentArgs() [ &lt;COMMACHAR&gt; ] )+ ) )+ ]
    * nodeOptional1 -> [ [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
    * nodeOptional2 -> [ [ &lt;ON&gt; ] &lt;EXCEPTION&gt; StatementList() ]
    * nodeOptional3 -> [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;EXCEPTION&gt; StatementList() ]
    * nodeOptional4 -> [ &lt;END_CALL&gt; ]
    * </PRE>
    */
   public void visit(CallStatement n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
      if ( n.nodeOptional4.present() ) {
         n.nodeOptional4.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> Identifier()
    *       | &lt;ADDRESS&gt; &lt;OF&gt; Identifier()
    *       | FileName()
    * </PRE>
    */
   public void visit(CallByReferenceArgs n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> [ &lt;LENGTH&gt; &lt;OF&gt; ] Identifier()
    *       | &lt;ADDRESS&gt; &lt;OF&gt; Identifier()
    *       | Literal()
    * </PRE>
    */
   public void visit(CallByContentArgs n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CANCEL&gt;
    * nodeList -> ( ( Identifier() | Literal() ) [ &lt;COMMACHAR&gt; ] )+
    * </PRE>
    */
   public void visit(CancelStatement n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CLOSE&gt;
    * nodeList -> ( FileName() [ ( ( &lt;REEL&gt; | &lt;UNIT&gt; ) [ ( [ &lt;FOR&gt; ] &lt;REMOVAL&gt; | [ &lt;WITH&gt; ] &lt;NO&gt; &lt;REWIND&gt; ) ] | [ &lt;WITH&gt; ] ( &lt;NO&gt; &lt;REWIND&gt; | &lt;LOCK&gt; ) ) ] [ &lt;COMMACHAR&gt; ] )+
    * </PRE>
    */
   public void visit(CloseStatement n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;COMPUTE&gt;
    * nodeList -> ( Identifier() [ &lt;ROUNDED&gt; ] )+
    * nodeChoice -> ( &lt;EQUALCHAR&gt; | &lt;EQUAL&gt; )
    * arithmeticExpression -> ArithmeticExpression()
    * nodeOptional -> [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional1 -> [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional2 -> [ &lt;END_COMPUTE&gt; ]
    * </PRE>
    */
   public void visit(ComputeStatement n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
      n.nodeChoice.accept(this);
      n.arithmeticExpression.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CONTINUE&gt;
    * </PRE>
    */
   public void visit(ContinueStatement n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;DELETE&gt;
    * fileName -> FileName()
    * nodeOptional -> [ &lt;RECORD&gt; ]
    * nodeOptional1 -> [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional2 -> [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional3 -> [ &lt;END_DELETE&gt; ]
    * </PRE>
    */
   public void visit(DeleteStatement n) {
      n.nodeToken.accept(this);
      n.fileName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;DISPLAY&gt;
    * nodeList -> ( ( Identifier() | Literal() ) [ &lt;COMMACHAR&gt; ] )+
    * nodeOptional -> [ &lt;UPON&gt; ( MnemonicName() | EnvironmentName() ) ]
    * nodeOptional1 -> [ [ &lt;WITH&gt; ] &lt;NO&gt; &lt;ADVANCING&gt; ]
    * </PRE>
    */
   public void visit(DisplayStatement n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;DIVIDE&gt;
    * divideBody -> DivideBody()
    * nodeOptional -> [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional1 -> [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional2 -> [ &lt;END_DIVIDE&gt; ]
    * </PRE>
    */
   public void visit(DivideStatement n) {
      n.nodeToken.accept(this);
      n.divideBody.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( IdOrLiteral() &lt;INTO&gt; ( IdOrLiteral() | ArithIdentifierList() ) [ &lt;GIVING&gt; ArithIdentifierList() [ &lt;REMAINDER&gt; ArithIdentifier() ] ] | IdOrLiteral() &lt;BY&gt; IdOrLiteral() &lt;GIVING&gt; ArithIdentifierList() [ &lt;REMAINDER&gt; ArithIdentifier() ] )
    * </PRE>
    */
   public void visit(DivideBody n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;ENTRY&gt;
    * literal -> Literal()
    * nodeOptional -> [ UsingArgs() ]
    * </PRE>
    */
   public void visit(EntryStatement n) {
      n.nodeToken.accept(this);
      n.literal.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;EVALUATE&gt;
    * evaluateValue -> EvaluateValue()
    * nodeListOptional -> ( &lt;ALSO&gt; EvaluateValue() )*
    * nodeList -> ( ( &lt;WHEN&gt; [ &lt;EQUALCHAR&gt; ] EvaluatePhrase() ( &lt;ALSO&gt; EvaluatePhrase() )* )+ StatementList() )+
    * nodeOptional -> [ &lt;WHEN&gt; &lt;OTHER&gt; StatementList() ]
    * nodeOptional1 -> [ &lt;END_EVALUATE&gt; ]
    * </PRE>
    */
   public void visit(EvaluateStatement n) {
      n.nodeToken.accept(this);
      n.evaluateValue.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      processList(n.nodeList);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( Identifier() | Condition() | ArithmeticExpression() | Literal() | &lt;TRUE&gt; | &lt;FALSE&gt; )
    * </PRE>
    */
   public void visit(EvaluateValue n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;ANY&gt; | [ &lt;NOT&gt; ] ( Identifier() | Literal() | ArithmeticExpression() ) [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) ( Identifier() | Literal() | ArithmeticExpression() ) ] | Condition() | &lt;TRUE&gt; | &lt;FALSE&gt; )
    * </PRE>
    */
   public void visit(EvaluatePhrase n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;EXIT&gt;
    * </PRE>
    */
   public void visit(ExitStatement n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;EXIT&gt;
    * nodeToken1 -> &lt;PROGRAM&gt;
    * </PRE>
    */
   public void visit(ExitProgramStatement n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;GOBACK&gt;
    * </PRE>
    */
   public void visit(GobackStatement n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;GO&gt;
    * nodeOptional -> [ &lt;TO&gt; ]
    * nodeChoice -> ( ProcedureName() [ ( ProcedureName() )* &lt;DEPENDING&gt; [ &lt;ON&gt; ] Identifier() ] | &lt;MORE_LABELS&gt; )
    * </PRE>
    */
   public void visit(GotoStatement n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;IF&gt;
    * condition -> Condition()
    * nodeOptional -> [ &lt;THEN&gt; ]
    * nodeChoice -> ( StatementList() [ &lt;NEXT&gt; &lt;SENTENCE&gt; ] | &lt;NEXT&gt; &lt;SENTENCE&gt; )
    * nodeOptional1 -> [ &lt;ELSE&gt; ( StatementList() [ &lt;NEXT&gt; &lt;SENTENCE&gt; ] | &lt;NEXT&gt; &lt;SENTENCE&gt; ) ]
    * nodeOptional2 -> [ &lt;END_IF&gt; ]
    * </PRE>
    */
   public void visit(IfStatement n) {
      n.nodeToken.accept(this);
      n.condition.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;INITIALIZE&gt;
    * nodeList -> ( Identifier() [ &lt;COMMACHAR&gt; ] )+
    * nodeOptional -> [ &lt;REPLACING&gt; ( ( &lt;ALPHABETIC&gt; | &lt;ALPHANUMERIC&gt; | &lt;NUMERIC&gt; | &lt;ALPHANUMERIC_EDITED&gt; | &lt;NUMERIC_EDITED&gt; | &lt;DBCS&gt; | &lt;EGCS&gt; ) [ &lt;DATA&gt; ] &lt;BY&gt; ( Identifier() | Literal() [ &lt;COMMACHAR&gt; ] ) )+ ]
    * </PRE>
    */
   public void visit(InitializeStatement n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;INSPECT&gt;
    * identifier -> Identifier()
    * nodeChoice -> ( TallyingPhrase() | ConvertingPhrase() | ReplacingPhrase() )
    * </PRE>
    */
   public void visit(InspectStatement n) {
      n.nodeToken.accept(this);
      n.identifier.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;TALLYING&gt;
    * nodeList -> ( Identifier() &lt;FOR&gt; ( &lt;CHARACTERS&gt; ( BeforeAfterPhrase() )* | ( &lt;ALL&gt; | &lt;LEADING&gt; ) ( ( Identifier() | Literal() ) ( BeforeAfterPhrase() )* )+ )+ )+
    * nodeOptional -> [ ReplacingPhrase() ]
    * </PRE>
    */
   public void visit(TallyingPhrase n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;CONVERTING&gt;
    * nodeChoice -> ( Identifier() | Literal() )
    * nodeToken1 -> &lt;TO&gt;
    * nodeChoice1 -> ( Identifier() | Literal() )
    * nodeListOptional -> ( BeforeAfterPhrase() )*
    * </PRE>
    */
   public void visit(ConvertingPhrase n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      n.nodeToken1.accept(this);
      n.nodeChoice1.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;REPLACING&gt;
    * nodeList -> ( &lt;CHARACTERS&gt; &lt;BY&gt; ( Identifier() | Literal() ) ( BeforeAfterPhrase() )* | ( &lt;ALL&gt; | &lt;LEADING&gt; | &lt;FIRST&gt; ) ( ( Identifier() | Literal() ) &lt;BY&gt; ( Identifier() | Literal() ) ( BeforeAfterPhrase() )* )+ )+
    * </PRE>
    */
   public void visit(ReplacingPhrase n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;BEFORE&gt; | &lt;AFTER&gt; )
    * nodeOptional -> [ &lt;INITIAL&gt; ]
    * nodeChoice1 -> ( Identifier() | Literal() )
    * </PRE>
    */
   public void visit(BeforeAfterPhrase n) {
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;MERGE&gt;
    * fileName -> FileName()
    * nodeList -> ( [ &lt;ON&gt; ] ( &lt;ASCENDING&gt; | &lt;DESCENDING&gt; ) [ &lt;KEY&gt; ] ( QualifiedDataName() [ &lt;COMMACHAR&gt; ] )+ )+
    * nodeOptional -> [ [ &lt;COLLATING&gt; ] &lt;SEQUENCE&gt; [ &lt;IS&gt; ] AlphabetName() ]
    * nodeToken1 -> &lt;USING&gt;
    * fileName1 -> FileName()
    * nodeList1 -> ( [ &lt;COMMACHAR&gt; ] FileName() )+
    * nodeChoice -> ( &lt;OUTPUT&gt; &lt;PROCEDURE&gt; [ &lt;IS&gt; ] ProcedureName() [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) ProcedureName() ] | &lt;GIVING&gt; ( FileName() )+ )
    * </PRE>
    */
   public void visit(MergeStatement n) {
      n.nodeToken.accept(this);
      n.fileName.accept(this);
      processList(n.nodeList);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
      n.fileName1.accept(this);
      processList(n.nodeList1);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;MOVE&gt;
    * nodeChoice -> ( ( Identifier() | Literal() ) &lt;TO&gt; ( Identifier() [ &lt;COMMACHAR&gt; ] )+ | ( &lt;CORRESPONDING&gt; | &lt;CORR&gt; ) Identifier() &lt;TO&gt; ( Identifier() [ &lt;COMMACHAR&gt; ] )+ )
    * </PRE>
    */
   public void visit(MoveStatement n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;MULTIPLY&gt;
    * multiplyBody -> MultiplyBody()
    * nodeOptional -> [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional1 -> [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional2 -> [ &lt;END_MULTIPLY&gt; ]
    * </PRE>
    */
   public void visit(MultiplyStatement n) {
      n.nodeToken.accept(this);
      n.multiplyBody.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * idOrLiteral -> IdOrLiteral()
    * nodeToken -> &lt;BY&gt;
    * nodeChoice -> ( IdOrLiteral() &lt;GIVING&gt; ArithIdentifierList() | ArithIdentifierList() )
    * </PRE>
    */
   public void visit(MultiplyBody n) {
      n.idOrLiteral.accept(this);
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;OPEN&gt;
    * nodeList -> ( &lt;INPUT&gt; ( FileName() [ ( &lt;REVERSED&gt; | [ &lt;WITH&gt; ] &lt;NO&gt; &lt;REWIND&gt; ) ] [ &lt;COMMACHAR&gt; ] )+ | &lt;OUTPUT&gt; ( FileName() [ [ &lt;WITH&gt; ] &lt;NO&gt; &lt;REWIND&gt; ] [ &lt;COMMACHAR&gt; ] )+ | &lt;I_O&gt; ( FileName() [ &lt;COMMACHAR&gt; ] )+ | &lt;EXTEND&gt; ( FileName() [ &lt;COMMACHAR&gt; ] )+ )+
    * </PRE>
    */
   public void visit(OpenStatement n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;PERFORM&gt;
    * performBody -> PerformBody()
    * </PRE>
    */
   public void visit(PerformStatement n) {
      n.nodeToken.accept(this);
      n.performBody.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> [ PerformOption() ] [ StatementList() ] &lt;END_PERFORM&gt;
    *       | PerformProcedure() [ PerformOption() ]
    * </PRE>
    */
   public void visit(PerformBody n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * procedureName -> ProcedureName()
    * nodeOptional -> [ ( &lt;THRU&gt; | &lt;THROUGH&gt; ) ProcedureName() ]
    * </PRE>
    */
   public void visit(PerformProcedure n) {
      n.procedureName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;BEFORE&gt;
    *       | &lt;AFTER&gt;
    * </PRE>
    */
   public void visit(BeforeOrAfter n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( Identifier() | Literal() ) &lt;TIMES&gt;
    *       | [ PerformTest() ] &lt;UNTIL&gt; Condition()
    *       | [ PerformTest() ] &lt;VARYING&gt; PerformVaryingList()
    * </PRE>
    */
   public void visit(PerformOption n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;WITH&gt; ]
    * nodeToken -> &lt;TEST&gt;
    * beforeOrAfter -> BeforeOrAfter()
    * </PRE>
    */
   public void visit(PerformTest n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.beforeOrAfter.accept(this);
   }

   /**
    * <PRE>
    * performVarying -> PerformVarying()
    * nodeListOptional -> ( &lt;AFTER&gt; PerformVarying() [ &lt;COMMACHAR&gt; ] )*
    * </PRE>
    */
   public void visit(PerformVaryingList n) {
      n.performVarying.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * identifier -> Identifier()
    * nodeToken -> &lt;FROM&gt;
    * idOrLiteral -> IdOrLiteral()
    * nodeToken1 -> &lt;BY&gt;
    * idOrLiteral1 -> IdOrLiteral()
    * nodeToken2 -> &lt;UNTIL&gt;
    * condition -> Condition()
    * </PRE>
    */
   public void visit(PerformVarying n) {
      n.identifier.accept(this);
      n.nodeToken.accept(this);
      n.idOrLiteral.accept(this);
      n.nodeToken1.accept(this);
      n.idOrLiteral1.accept(this);
      n.nodeToken2.accept(this);
      n.condition.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;READ&gt;
    * fileName -> FileName()
    * nodeOptional -> [ &lt;NEXT&gt; ]
    * nodeOptional1 -> [ &lt;RECORD&gt; ]
    * nodeOptional2 -> [ &lt;INTO&gt; Identifier() ]
    * nodeOptional3 -> [ &lt;KEY&gt; [ &lt;IS&gt; ] QualifiedDataName() ]
    * nodeOptional4 -> [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional5 -> [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional6 -> [ [ &lt;AT&gt; ] &lt;END&gt; StatementList() ]
    * nodeOptional7 -> [ &lt;NOT&gt; [ &lt;AT&gt; ] &lt;END&gt; StatementList() ]
    * nodeOptional8 -> [ &lt;END_READ&gt; ]
    * </PRE>
    */
   public void visit(ReadStatement n) {
      n.nodeToken.accept(this);
      n.fileName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
      if ( n.nodeOptional4.present() ) {
         n.nodeOptional4.accept(this);
      }
      if ( n.nodeOptional5.present() ) {
         n.nodeOptional5.accept(this);
      }
      if ( n.nodeOptional6.present() ) {
         n.nodeOptional6.accept(this);
      }
      if ( n.nodeOptional7.present() ) {
         n.nodeOptional7.accept(this);
      }
      if ( n.nodeOptional8.present() ) {
         n.nodeOptional8.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RELEASE&gt;
    * recordName -> RecordName()
    * nodeOptional -> [ &lt;FROM&gt; QualifiedDataName() ]
    * </PRE>
    */
   public void visit(ReleaseStatement n) {
      n.nodeToken.accept(this);
      n.recordName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;RETURN&gt;
    * fileName -> FileName()
    * nodeOptional -> [ &lt;RECORD&gt; ]
    * nodeOptional1 -> [ &lt;INTO&gt; QualifiedDataName() ]
    * nodeOptional2 -> [ &lt;AT&gt; ]
    * nodeToken1 -> &lt;END&gt;
    * statementList -> StatementList()
    * nodeOptional3 -> [ &lt;NOT&gt; [ &lt;AT&gt; ] &lt;END&gt; StatementList() ]
    * nodeOptional4 -> [ &lt;END_RETURN&gt; ]
    * </PRE>
    */
   public void visit(ReturnStatement n) {
      n.nodeToken.accept(this);
      n.fileName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      n.nodeToken1.accept(this);
      n.statementList.accept(this);
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
      if ( n.nodeOptional4.present() ) {
         n.nodeOptional4.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;REWRITE&gt;
    * recordName -> RecordName()
    * nodeOptional -> [ &lt;FROM&gt; Identifier() ]
    * nodeOptional1 -> [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional2 -> [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional3 -> [ &lt;END_REWRITE&gt; ]
    * </PRE>
    */
   public void visit(RewriteStatement n) {
      n.nodeToken.accept(this);
      n.recordName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SEARCH&gt;
    * nodeOptional -> [ &lt;ALL&gt; ]
    * qualifiedDataName -> QualifiedDataName()
    * nodeOptional1 -> [ &lt;VARYING&gt; QualifiedDataName() ]
    * nodeOptional2 -> [ [ &lt;AT&gt; ] &lt;END&gt; StatementList() ]
    * nodeList -> ( &lt;WHEN&gt; Condition() ( StatementList() | &lt;NEXT&gt; &lt;SENTENCE&gt; ) )+
    * nodeOptional3 -> [ &lt;END_SEARCH&gt; ]
    * </PRE>
    */
   public void visit(SearchStatement n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.qualifiedDataName.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      processList(n.nodeList);
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SET&gt;
    * nodeList -> ( ( Identifier() [ &lt;COMMACHAR&gt; ] )+ ( &lt;TO&gt; ( Identifier() | &lt;TRUE&gt; | &lt;FALSE&gt; | &lt;ON&gt; | &lt;OFF&gt; | Literal() ) | ( &lt;UP&gt; | &lt;DOWN&gt; ) [ &lt;BY&gt; ] ( Identifier() | Literal() ) ) )+
    * </PRE>
    */
   public void visit(SetStatement n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SORT&gt;
    * fileName -> FileName()
    * nodeList -> ( [ &lt;ON&gt; ] ( &lt;ASCENDING&gt; | &lt;DESCENDING&gt; ) [ &lt;KEY&gt; ] ( QualifiedDataName() [ &lt;COMMACHAR&gt; ] )+ )+
    * nodeOptional -> [ [ &lt;WITH&gt; ] &lt;DUPLICATES&gt; [ &lt;IN&gt; ] [ &lt;ORDER&gt; ] ]
    * nodeOptional1 -> [ [ &lt;COLLATING&gt; ] &lt;SEQUENCE&gt; [ &lt;IS&gt; ] AlphabetName() ]
    * nodeChoice -> ( &lt;USING&gt; ( FileName() )+ | &lt;INPUT&gt; &lt;PROCEDURE&gt; [ &lt;IS&gt; ] ProcedureName() [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) ProcedureName() ] )
    * nodeChoice1 -> ( &lt;GIVING&gt; ( FileName() )+ | &lt;OUTPUT&gt; &lt;PROCEDURE&gt; [ &lt;IS&gt; ] ProcedureName() [ ( &lt;THROUGH&gt; | &lt;THRU&gt; ) ProcedureName() ] )
    * </PRE>
    */
   public void visit(SortStatement n) {
      n.nodeToken.accept(this);
      n.fileName.accept(this);
      processList(n.nodeList);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;START&gt;
    * fileName -> FileName()
    * nodeOptional -> [ &lt;KEY&gt; [ &lt;IS&gt; ] ( &lt;EQUAL&gt; [ &lt;TO&gt; ] | &lt;EQUALCHAR&gt; | &lt;GREATER&gt; [ &lt;THAN&gt; ] &lt;OR&gt; &lt;EQUAL&gt; [ &lt;TO&gt; ] | &lt;GREATER&gt; [ &lt;THAN&gt; ] | &lt;MORETHANCHAR&gt; | &lt;NOT&gt; &lt;LESS&gt; [ &lt;THAN&gt; ] | &lt;NOT&gt; &lt;LESSTHANCHAR&gt; | &lt;MORETHANOREQUAL&gt; ) QualifiedDataName() ]
    * nodeOptional1 -> [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional2 -> [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional3 -> [ &lt;END_START&gt; ]
    * </PRE>
    */
   public void visit(StartStatement n) {
      n.nodeToken.accept(this);
      n.fileName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;STOP&gt;
    * nodeChoice -> ( &lt;RUN&gt; | Literal() )
    * </PRE>
    */
   public void visit(StopStatement n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;STRING&gt;
    * nodeList -> ( ( Identifier() | Literal() )+ [ &lt;DELIMITED&gt; [ &lt;BY&gt; ] ( Identifier() | Literal() | &lt;SIZE&gt; ) ] )+
    * nodeToken1 -> &lt;INTO&gt;
    * identifier -> Identifier()
    * nodeOptional -> [ [ &lt;WITH&gt; ] &lt;POINTER&gt; QualifiedDataName() ]
    * nodeOptional1 -> [ [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
    * nodeOptional2 -> [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
    * nodeOptional3 -> [ &lt;END_STRING&gt; ]
    * </PRE>
    */
   public void visit(StringStatement n) {
      n.nodeToken.accept(this);
      processList(n.nodeList);
      n.nodeToken1.accept(this);
      n.identifier.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;SUBTRACT&gt;
    * nodeChoice -> ( IdOrLiteralList() &lt;FROM&gt; ( IdOrLiteral() &lt;GIVING&gt; ArithIdentifierList() | ArithIdentifierList() ) | ( &lt;CORRESPONDING&gt; | &lt;CORR&gt; ) QualifiedDataName() &lt;FROM&gt; QualifiedDataName() )
    * nodeOptional -> [ [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional1 -> [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;SIZE&gt; &lt;ERROR&gt; StatementList() ]
    * nodeOptional2 -> [ &lt;END_SUBTRACT&gt; ]
    * </PRE>
    */
   public void visit(SubtractStatement n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;UNSTRING&gt;
    * identifier -> Identifier()
    * nodeOptional -> [ &lt;DELIMITED&gt; [ &lt;BY&gt; ] [ &lt;ALL&gt; ] ( Identifier() | Literal() ) ( &lt;OR&gt; [ &lt;ALL&gt; ] ( Identifier() | Literal() ) )* ]
    * nodeToken1 -> &lt;INTO&gt;
    * nodeList -> ( Identifier() [ &lt;DELIMITER&gt; [ &lt;IN&gt; ] Identifier() ] [ &lt;COUNT&gt; [ &lt;IN&gt; ] Identifier() ] [ &lt;COMMACHAR&gt; ] )+
    * nodeOptional1 -> [ [ &lt;WITH&gt; ] &lt;POINTER&gt; QualifiedDataName() ]
    * nodeOptional2 -> [ &lt;TALLYING&gt; [ &lt;IN&gt; ] QualifiedDataName() ]
    * nodeOptional3 -> [ [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
    * nodeOptional4 -> [ &lt;NOT&gt; [ &lt;ON&gt; ] &lt;OVERFLOW&gt; StatementList() ]
    * nodeOptional5 -> [ &lt;END_UNSTRING&gt; ]
    * </PRE>
    */
   public void visit(UnstringStatement n) {
      n.nodeToken.accept(this);
      n.identifier.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
      processList(n.nodeList);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
      if ( n.nodeOptional4.present() ) {
         n.nodeOptional4.accept(this);
      }
      if ( n.nodeOptional5.present() ) {
         n.nodeOptional5.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;USE&gt;
    * nodeChoice -> ( [ &lt;FOR&gt; ] &lt;DEBUGGING&gt; [ &lt;ON&gt; ] ( ( Identifier() | &lt;ALL&gt; [ &lt;REFERENCES&gt; ] [ &lt;OF&gt; ] Identifier() | FileName() | ProcedureName() )+ | &lt;ALL&gt; &lt;PROCEDURES&gt; ) | [ &lt;GLOBAL&gt; ] &lt;AFTER&gt; [ &lt;STANDARD&gt; ] ( ( &lt;EXCEPTION&gt; | &lt;ERROR&gt; ) | [ ( &lt;BEGINNING&gt; | &lt;ENDING&gt; ) ] [ ( &lt;FILE&gt; | &lt;REEL&gt; | &lt;UNIT&gt; ) ] &lt;LABEL&gt; ) &lt;PROCEDURE&gt; [ &lt;ON&gt; ] ( ( FileName() [ &lt;COMMACHAR&gt; ] )+ | &lt;INPUT&gt; | &lt;OUTPUT&gt; | &lt;I_O&gt; | &lt;EXTEND&gt; ) )
    * </PRE>
    */
   public void visit(UseStatement n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;WRITE&gt;
    * recordName -> RecordName()
    * nodeOptional -> [ &lt;FROM&gt; ( Identifier() | Literal() ) ]
    * nodeOptional1 -> [ AdvancingPhrase() ]
    * nodeOptional2 -> [ [ &lt;AT&gt; ] ( &lt;END_OF_PAGE&gt; | &lt;EOP&gt; ) StatementList() ]
    * nodeOptional3 -> [ &lt;NOT&gt; [ &lt;AT&gt; ] ( &lt;END_OF_PAGE&gt; | &lt;EOP&gt; ) StatementList() ]
    * nodeOptional4 -> [ &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional5 -> [ &lt;NOT&gt; &lt;INVALID&gt; [ &lt;KEY&gt; ] StatementList() ]
    * nodeOptional6 -> [ &lt;END_WRITE&gt; ]
    * </PRE>
    */
   public void visit(WriteStatement n) {
      n.nodeToken.accept(this);
      n.recordName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
      if ( n.nodeOptional4.present() ) {
         n.nodeOptional4.accept(this);
      }
      if ( n.nodeOptional5.present() ) {
         n.nodeOptional5.accept(this);
      }
      if ( n.nodeOptional6.present() ) {
         n.nodeOptional6.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;BEFORE&gt; | &lt;AFTER&gt; )
    * nodeOptional -> [ &lt;ADVANCING&gt; ]
    * nodeChoice1 -> ( &lt;PAGE&gt; | ( Identifier() | IntegerConstant() | FigurativeConstant() ) [ ( &lt;LINE&gt; | &lt;LINES&gt; ) ] | MnemonicName() )
    * </PRE>
    */
   public void visit(AdvancingPhrase n) {
      n.nodeChoice.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;S_IDENTIFIER&gt;
    * </PRE>
    */
   public void visit(S_Identifier n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;S_QUOTED_IDENTIFIER&gt;
    * </PRE>
    */
   public void visit(S_Quoted_Identifier n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;S_CHAR_LITERAL&gt;
    * </PRE>
    */
   public void visit(S_Char_Literal n) {
      n.nodeToken.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> SQLCloseStatement()
    *       | CommitStatement()
    *       | [ SQLUsingDMLReturn() ] ( SQLDeleteStatement() | InsertStatement() | UpdateStatement() )
    *       | FetchStatement()
    *       | LockTableStatement()
    *       | SQLOpenStatement()
    *       | RollbackStatement()
    *       | SavepointStatement()
    *       | QueryStatement()
    *       | SQLSetStatement()
    * </PRE>
    */
   public void visit(SQLStatement n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_CLOSE&gt;
    * relObjectName -> RelObjectName()
    * </PRE>
    */
   public void visit(SQLCloseStatement n) {
      n.nodeToken.accept(this);
      n.relObjectName.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_COMMIT&gt;
    * nodeOptional -> [ &lt;K_WORK&gt; ]
    * nodeOptional1 -> [ &lt;K_COMMENT&gt; S_Char_Literal() ]
    * </PRE>
    */
   public void visit(CommitStatement n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;K_FOR&gt; ( RelObjectName() | &lt;S_BIND&gt; ) ]
    * nodeToken -> &lt;K_FETCH&gt;
    * nodeSequence -> ( RelObjectName() )
    * nodeToken1 -> &lt;K_INTO&gt;
    * nodeChoice -> ( RelObjectName() [ [ &lt;K_INDICATOR&gt; ] &lt;S_BIND&gt; ] | IndicatorBind() )
    * nodeListOptional -> ( &lt;COMMACHAR&gt; ( RelObjectName() [ [ &lt;K_INDICATOR&gt; ] &lt;S_BIND&gt; ] | IndicatorBind() ) )*
    * </PRE>
    */
   public void visit(FetchStatement n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.nodeSequence.accept(this);
      n.nodeToken1.accept(this);
      n.nodeChoice.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;S_BIND&gt;
    * nodeOptional -> [ [ &lt;K_INDICATOR&gt; ] &lt;S_BIND&gt; ]
    * </PRE>
    */
   public void visit(IndicatorBind n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_LOCK&gt;
    * nodeToken1 -> &lt;K_TABLE&gt;
    * tableReference -> TableReference()
    * nodeListOptional -> ( &lt;COMMACHAR&gt; TableReference() )*
    * nodeToken2 -> &lt;K_IN&gt;
    * lockMode -> LockMode()
    * nodeToken3 -> &lt;K_MODE&gt;
    * nodeOptional -> [ &lt;K_NOWAIT&gt; ]
    * </PRE>
    */
   public void visit(LockTableStatement n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.tableReference.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
      n.nodeToken2.accept(this);
      n.lockMode.accept(this);
      n.nodeToken3.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_OPEN&gt;
    * relObjectName -> RelObjectName()
    * nodeOptional -> [ &lt;K_USING&gt; Arguments() ]
    * </PRE>
    */
   public void visit(SQLOpenStatement n) {
      n.nodeToken.accept(this);
      n.relObjectName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_ROLLBACK&gt;
    * nodeOptional -> [ &lt;K_WORK&gt; ]
    * nodeOptional1 -> [ &lt;K_TO&gt; [ &lt;K_SAVEPOINT&gt; ] RelObjectName() ]
    * nodeOptional2 -> [ &lt;K_COMMENT&gt; S_Char_Literal() ]
    * </PRE>
    */
   public void visit(RollbackStatement n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_SET&gt;
    * nodeToken1 -> &lt;K_TRANSACTION&gt;
    * nodeChoice -> ( ( &lt;K_READ&gt; ( &lt;K_ONLY&gt; | &lt;K_WRITE&gt; ) ) | ( &lt;K_USE&gt; &lt;K_ROLLBACK&gt; &lt;K_SEGMENT&gt; RelObjectName() ) )
    * </PRE>
    */
   public void visit(SetTransactionStatement n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_SET&gt;
    * relObjectName -> RelObjectName()
    * nodeChoice -> ( &lt;K_TO&gt; | "=" )
    * arguments -> Arguments()
    * </PRE>
    */
   public void visit(SetVariableStatement n) {
      n.nodeToken.accept(this);
      n.relObjectName.accept(this);
      n.nodeChoice.accept(this);
      n.arguments.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> SetTransactionStatement()
    *       | SetVariableStatement()
    * </PRE>
    */
   public void visit(SQLSetStatement n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;K_ROW&gt; ( &lt;K_SHARE&gt; | &lt;K_EXCLUSIVE&gt; ) )
    *       | ( &lt;K_SHARE&gt; [ &lt;K_UPDATE&gt; | ( &lt;K_ROW&gt; &lt;K_EXCLUSIVE&gt; ) ] )
    *       | ( &lt;K_EXCLUSIVE&gt; )
    * </PRE>
    */
   public void visit(LockMode n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_SAVEPOINT&gt;
    * relObjectName -> RelObjectName()
    * </PRE>
    */
   public void visit(SavepointStatement n) {
      n.nodeToken.accept(this);
      n.relObjectName.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_UPDATE&gt;
    * tableReference -> TableReference()
    * nodeOptional -> [ RelObjectName() ]
    * nodeToken1 -> &lt;K_SET&gt;
    * columnValues -> ColumnValues()
    * nodeOptional1 -> [ &lt;K_WHERE&gt; ( SQLExpression() | &lt;K_CURRENT&gt; &lt;K_OF&gt; RelObjectName() ) ]
    * </PRE>
    */
   public void visit(UpdateStatement n) {
      n.nodeToken.accept(this);
      n.tableReference.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
      n.columnValues.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * tableColumn -> TableColumn()
    * nodeToken -> "="
    * updatedValue -> UpdatedValue()
    * nodeListOptional -> ( &lt;COMMACHAR&gt; TableColumn() "=" UpdatedValue() )*
    * </PRE>
    */
   public void visit(ColumnValues n) {
      n.tableColumn.accept(this);
      n.nodeToken.accept(this);
      n.updatedValue.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;LPARENCHAR&gt; SelectStatement() &lt;RPARENCHAR&gt;
    *       | PlSqlExpression()
    * </PRE>
    */
   public void visit(UpdatedValue n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_INSERT&gt;
    * nodeToken1 -> &lt;K_INTO&gt;
    * tableReference -> TableReference()
    * nodeOptional -> [ &lt;LPARENCHAR&gt; TableColumn() ( &lt;COMMACHAR&gt; TableColumn() )* &lt;RPARENCHAR&gt; ]
    * nodeChoice -> ( &lt;K_VALUES&gt; &lt;LPARENCHAR&gt; PlSqlExpressionList() &lt;RPARENCHAR&gt; | SelectStatement() )
    * </PRE>
    */
   public void visit(InsertStatement n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.tableReference.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_USING&gt;
    * nodeChoice -> ( &lt;S_IDENTIFIER&gt; | &lt;S_BIND&gt; )
    * </PRE>
    */
   public void visit(SQLUsingDMLReturn n) {
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_DELETE&gt;
    * nodeOptional -> [ &lt;K_FROM&gt; ]
    * tableReference -> TableReference()
    * nodeOptional1 -> [ RelObjectName() ]
    * nodeOptional2 -> [ &lt;K_WHERE&gt; ( SQLExpression() | &lt;K_CURRENT&gt; &lt;K_OF&gt; RelObjectName() ) ]
    * </PRE>
    */
   public void visit(SQLDeleteStatement n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.tableReference.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
   }

   /**
    * <PRE>
    * selectStatement -> SelectStatement()
    * </PRE>
    */
   public void visit(QueryStatement n) {
      n.selectStatement.accept(this);
   }

   /**
    * <PRE>
    * plSqlExpressions -> PlSqlExpressions()
    * </PRE>
    */
   public void visit(PlSqlExpression n) {
      n.plSqlExpressions.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> PlSqlOrExpression()
    *       | PlSqlAndExpressions()
    * </PRE>
    */
   public void visit(PlSqlExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * plSqlAndExpressions -> PlSqlAndExpressions()
    * nodeList -> ( &lt;K_OR&gt; PlSqlAndExpressions() )+
    * </PRE>
    */
   public void visit(PlSqlOrExpression n) {
      n.plSqlAndExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> PlSqlAndExpression()
    *       | PlSqlUnaryLogicalExpressions()
    * </PRE>
    */
   public void visit(PlSqlAndExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * plSqlUnaryLogicalExpressions -> PlSqlUnaryLogicalExpressions()
    * nodeList -> ( &lt;K_AND&gt; PlSqlUnaryLogicalExpressions() )+
    * </PRE>
    */
   public void visit(PlSqlAndExpression n) {
      n.plSqlUnaryLogicalExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> PlSqlUnaryLogicalExpression()
    *       | PlSqlRelationalExpressions()
    * </PRE>
    */
   public void visit(PlSqlUnaryLogicalExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_NOT&gt;
    * plSqlRelationalExpressions -> PlSqlRelationalExpressions()
    * </PRE>
    */
   public void visit(PlSqlUnaryLogicalExpression n) {
      n.nodeToken.accept(this);
      n.plSqlRelationalExpressions.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> PlSqlRelationalExpression()
    *       | PlSqlSimpleExpressions()
    * </PRE>
    */
   public void visit(PlSqlRelationalExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * plSqlSimpleExpressions -> PlSqlSimpleExpressions()
    * nodeChoice -> ( Relop() PlSqlSimpleExpressions() | PlSqlInClause() | PlSqlBetweenClause() | PlSqlLikeClause() | IsNullClause() )
    * </PRE>
    */
   public void visit(PlSqlRelationalExpression n) {
      n.plSqlSimpleExpressions.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * plSqlExpression -> PlSqlExpression()
    * nodeListOptional -> ( &lt;COMMACHAR&gt; PlSqlExpression() )*
    * </PRE>
    */
   public void visit(PlSqlExpressionList n) {
      n.plSqlExpression.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;K_NOT&gt; ]
    * nodeToken -> &lt;K_IN&gt;
    * nodeToken1 -> &lt;LPARENCHAR&gt;
    * plSqlExpressionList -> PlSqlExpressionList()
    * nodeToken2 -> &lt;RPARENCHAR&gt;
    * </PRE>
    */
   public void visit(PlSqlInClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.plSqlExpressionList.accept(this);
      n.nodeToken2.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;K_NOT&gt; ]
    * nodeToken -> &lt;K_BETWEEN&gt;
    * plSqlSimpleExpressions -> PlSqlSimpleExpressions()
    * nodeToken1 -> &lt;K_AND&gt;
    * plSqlSimpleExpressions1 -> PlSqlSimpleExpressions()
    * </PRE>
    */
   public void visit(PlSqlBetweenClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.plSqlSimpleExpressions.accept(this);
      n.nodeToken1.accept(this);
      n.plSqlSimpleExpressions1.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;K_NOT&gt; ]
    * nodeToken -> &lt;K_LIKE&gt;
    * plSqlSimpleExpressions -> PlSqlSimpleExpressions()
    * </PRE>
    */
   public void visit(PlSqlLikeClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.plSqlSimpleExpressions.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_IS&gt;
    * nodeOptional -> [ &lt;K_NOT&gt; ]
    * nodeToken1 -> &lt;K_NULL&gt;
    * </PRE>
    */
   public void visit(IsNullClause n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken1.accept(this);
   }

   /**
    * <PRE>
    * plSqlSimpleExpressions -> PlSqlSimpleExpressions()
    * </PRE>
    */
   public void visit(PlSqlSimpleExpression n) {
      n.plSqlSimpleExpressions.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> PlSqlAdditiveExpression()
    *       | PlSqlMultiplicativeExpressions()
    * </PRE>
    */
   public void visit(PlSqlSimpleExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * plSqlMultiplicativeExpressions -> PlSqlMultiplicativeExpressions()
    * nodeList -> ( ( ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; ) | ( &lt;MINUSCHAR&gt; | &lt;MINUSCHAR_SUBS&gt; ) | "||" ) PlSqlMultiplicativeExpressions() )+
    * </PRE>
    */
   public void visit(PlSqlAdditiveExpression n) {
      n.plSqlMultiplicativeExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> PlSqlMultiplicativeExpression()
    *       | PlSqlExpotentExpressions()
    * </PRE>
    */
   public void visit(PlSqlMultiplicativeExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * plSqlExpotentExpressions -> PlSqlExpotentExpressions()
    * nodeList -> ( ( "*" | "/" ) PlSqlExpotentExpressions() )+
    * </PRE>
    */
   public void visit(PlSqlMultiplicativeExpression n) {
      n.plSqlExpotentExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> PlSqlExpotentExpression()
    *       | PlSqlUnaryExpressions()
    * </PRE>
    */
   public void visit(PlSqlExpotentExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * plSqlUnaryExpressions -> PlSqlUnaryExpressions()
    * nodeList -> ( &lt;POW&gt; PlSqlUnaryExpressions() )+
    * </PRE>
    */
   public void visit(PlSqlExpotentExpression n) {
      n.plSqlUnaryExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> PlSqlUnaryExpression()
    *       | PlSqlPrimaryExpression()
    * </PRE>
    */
   public void visit(PlSqlUnaryExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeSequence -> ( ( ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; ) | ( &lt;MINUSCHAR&gt; | &lt;MINUSCHAR_SUBS&gt; ) ) PlSqlPrimaryExpression() )
    * </PRE>
    */
   public void visit(PlSqlUnaryExpression n) {
      n.nodeSequence.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;K_NULL&gt;
    *       | ( RelObjectName() ( "%FOUND" | "%NOTFOUND" | "%ISOPEN" | "%ROWCOUNT" ) )
    *       | ( RelObjectName() &lt;LPARENCHAR&gt; Arguments() &lt;RPARENCHAR&gt; )
    *       | ( RelObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] )
    *       | ( &lt;K_SQL&gt; ( "%FOUND" | "%NOTFOUND" | "%ISOPEN" | "%ROWCOUNT" ) )
    *       | &lt;S_NUMBER&gt;
    *       | IndicatorBind()
    *       | &lt;LPARENCHAR&gt; PlSqlExpression() &lt;RPARENCHAR&gt;
    * </PRE>
    */
   public void visit(PlSqlPrimaryExpression n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * relObjectName -> RelObjectName()
    * nodeOptional -> [ &lt;DOTCHAR&gt; DotObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] ]
    * </PRE>
    */
   public void visit(TableColumn n) {
      n.relObjectName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;S_IDENTIFIER&gt;
    *       | &lt;S_QUOTED_IDENTIFIER&gt;
    *       | &lt;S_CHAR_LITERAL&gt;
    * </PRE>
    */
   public void visit(RelObjectName n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;S_IDENTIFIER&gt;
    *       | &lt;S_QUOTED_IDENTIFIER&gt;
    *       | &lt;S_CHAR_LITERAL&gt;
    * </PRE>
    */
   public void visit(DotObjectName n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;S_IDENTIFIER&gt;
    *       | &lt;S_QUOTED_IDENTIFIER&gt;
    * </PRE>
    */
   public void visit(OracleObjectName n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> "="
    *       | "!="
    *       | "#"
    *       | "&lt;&gt;"
    *       | &lt;MORETHANCHAR&gt;
    *       | &lt;MORETHANOREQUAL&gt;
    *       | &lt;LESSTHANCHAR&gt;
    *       | &lt;LESSTHANOREQUAL&gt;
    * </PRE>
    */
   public void visit(Relop n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * relObjectName -> RelObjectName()
    * nodeOptional -> [ "/" DotObjectName() ]
    * </PRE>
    */
   public void visit(TableReference n) {
      n.relObjectName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;S_IDENTIFIER&gt;
    *       | ( [ ( ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; ) | ( &lt;MINUSCHAR&gt; | &lt;MINUSCHAR_SUBS&gt; ) ) ] &lt;S_NUMBER&gt; )
    * </PRE>
    */
   public void visit(NumOrID n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * plSqlExpressionList -> PlSqlExpressionList()
    * </PRE>
    */
   public void visit(Arguments n) {
      n.plSqlExpressionList.accept(this);
   }

   /**
    * <PRE>
    * selectWithoutOrder -> SelectWithoutOrder()
    * nodeOptional -> [ OrderByClause() ]
    * nodeOptional1 -> [ ForUpdateClause() ]
    * </PRE>
    */
   public void visit(SelectStatement n) {
      n.selectWithoutOrder.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_SELECT&gt;
    * nodeOptional -> [ &lt;K_ALL&gt; | &lt;K_DISTINCT&gt; ]
    * selectList -> SelectList()
    * nodeOptional1 -> [ IntoClause() ]
    * fromClause -> FromClause()
    * nodeOptional2 -> [ WhereClause() ]
    * nodeOptional3 -> [ ConnectClause() ]
    * nodeOptional4 -> [ GroupByClause() ]
    * nodeOptional5 -> [ SetClause() ]
    * </PRE>
    */
   public void visit(SelectWithoutOrder n) {
      n.nodeToken.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.selectList.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.fromClause.accept(this);
      if ( n.nodeOptional2.present() ) {
         n.nodeOptional2.accept(this);
      }
      if ( n.nodeOptional3.present() ) {
         n.nodeOptional3.accept(this);
      }
      if ( n.nodeOptional4.present() ) {
         n.nodeOptional4.accept(this);
      }
      if ( n.nodeOptional5.present() ) {
         n.nodeOptional5.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;ASTERISKCHAR&gt;
    *       | SelectItem() ( &lt;COMMACHAR&gt; SelectItem() )*
    * </PRE>
    */
   public void visit(SelectList n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> SelectAllItems()
    *       | SQLSimpleExpression() [ &lt;S_IDENTIFIER&gt; ]
    *       | FunctionCall() [ AsObjectName() ]
    *       | SelectAllItems()
    *       | TableColumn() [ AsObjectName() ]
    * </PRE>
    */
   public void visit(SelectItem n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> RelObjectName() &lt;DOTCHAR&gt; &lt;ASTERISKCHAR&gt;
    *       | RelObjectName() &lt;DOTCHAR&gt; DotObjectName() &lt;DOTCHAR&gt; &lt;ASTERISKCHAR&gt;
    * </PRE>
    */
   public void visit(SelectAllItems n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> RelObjectName()
    *       | &lt;K_AS&gt; DotObjectName()
    * </PRE>
    */
   public void visit(AsObjectName n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_INTO&gt;
    * intoItem -> IntoItem()
    * nodeListOptional -> ( &lt;COMMACHAR&gt; IntoItem() )*
    * </PRE>
    */
   public void visit(IntoClause n) {
      n.nodeToken.accept(this);
      n.intoItem.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( RelObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] )
    *       | ( IndicatorBind() )
    * </PRE>
    */
   public void visit(IntoItem n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_FROM&gt;
    * fromItem -> FromItem()
    * nodeListOptional -> ( &lt;COMMACHAR&gt; FromItem() )*
    * </PRE>
    */
   public void visit(FromClause n) {
      n.nodeToken.accept(this);
      n.fromItem.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( TableReference() | &lt;LPARENCHAR&gt; FromItemExpression() &lt;RPARENCHAR&gt; )
    * nodeChoice1 -> ( JoinerExpression() [ &lt;K_AS&gt; AsObjectName() ] | [ AsObjectName() ] )
    * </PRE>
    */
   public void visit(FromItem n) {
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( TableReference() | &lt;LPARENCHAR&gt; FromItemExpression() &lt;RPARENCHAR&gt; ) ( JoinerExpression() )*
    *       | SelectStatement()
    * </PRE>
    */
   public void visit(FromItemExpression n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;K_JOIN&gt; TableReference() [ JoinWhereClause() ]
    *       | RelObjectName() &lt;K_JOIN&gt; TableReference() [ JoinWhereClause() ]
    * </PRE>
    */
   public void visit(JoinerExpression n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_ON&gt;
    * sQLExpression -> SQLExpression()
    * </PRE>
    */
   public void visit(JoinWhereClause n) {
      n.nodeToken.accept(this);
      n.sQLExpression.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_WHERE&gt;
    * sQLExpression -> SQLExpression()
    * </PRE>
    */
   public void visit(WhereClause n) {
      n.nodeToken.accept(this);
      n.sQLExpression.accept(this);
   }

   /**
    * <PRE>
    * nodeSequence -> ( [ &lt;K_START&gt; &lt;K_WITH&gt; SQLExpression() ] &lt;K_CONNECT&gt; &lt;K_BY&gt; SQLExpression() [ &lt;K_START&gt; &lt;K_WITH&gt; SQLExpression() ] )
    * </PRE>
    */
   public void visit(ConnectClause n) {
      n.nodeSequence.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_GROUP&gt;
    * nodeToken1 -> &lt;K_BY&gt;
    * sQLExpressionList -> SQLExpressionList()
    * nodeOptional -> [ &lt;K_HAVING&gt; SQLExpression() ]
    * </PRE>
    */
   public void visit(GroupByClause n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.sQLExpressionList.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( ( &lt;K_UNION&gt; [ &lt;K_ALL&gt; ] ) | &lt;K_INTERSECT&gt; | &lt;K_MINUS&gt; )
    * nodeChoice1 -> ( ( &lt;LPARENCHAR&gt; SelectStatement() &lt;RPARENCHAR&gt; ) | SelectStatement() )
    * </PRE>
    */
   public void visit(SetClause n) {
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_ORDER&gt;
    * nodeToken1 -> &lt;K_BY&gt;
    * sQLSimpleExpression -> SQLSimpleExpression()
    * nodeOptional -> [ &lt;K_ASC&gt; | &lt;K_DESC&gt; ]
    * nodeListOptional -> ( &lt;COMMACHAR&gt; SQLSimpleExpression() [ &lt;K_ASC&gt; | &lt;K_DESC&gt; ] )*
    * </PRE>
    */
   public void visit(OrderByClause n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.sQLSimpleExpression.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeToken -> &lt;K_FOR&gt;
    * nodeToken1 -> &lt;K_UPDATE&gt;
    * nodeOptional -> [ &lt;K_OF&gt; TableColumn() ( &lt;COMMACHAR&gt; TableColumn() )* ]
    * </PRE>
    */
   public void visit(ForUpdateClause n) {
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
   }

   /**
    * <PRE>
    * sQLOrExpressions -> SQLOrExpressions()
    * </PRE>
    */
   public void visit(SQLExpression n) {
      n.sQLOrExpressions.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> SQLOrExpression()
    *       | SQLAndExpressions()
    * </PRE>
    */
   public void visit(SQLOrExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * sQLAndExpressions -> SQLAndExpressions()
    * nodeList -> ( &lt;K_OR&gt; SQLAndExpressions() )+
    * </PRE>
    */
   public void visit(SQLOrExpression n) {
      n.sQLAndExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> SQLAndExpression()
    *       | SQLUnaryLogicalExpressions()
    * </PRE>
    */
   public void visit(SQLAndExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * sQLUnaryLogicalExpressions -> SQLUnaryLogicalExpressions()
    * nodeList -> ( &lt;K_AND&gt; SQLUnaryLogicalExpressions() )+
    * </PRE>
    */
   public void visit(SQLAndExpression n) {
      n.sQLUnaryLogicalExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> ExistsClause()
    *       | SQLRelationalExpressions()
    * </PRE>
    */
   public void visit(SQLUnaryLogicalExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;K_NOT&gt; ]
    * nodeToken -> &lt;K_EXISTS&gt;
    * nodeToken1 -> &lt;LPARENCHAR&gt;
    * subQuery -> SubQuery()
    * nodeToken2 -> &lt;RPARENCHAR&gt;
    * </PRE>
    */
   public void visit(ExistsClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.subQuery.accept(this);
      n.nodeToken2.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> SQLRelationalExpression()
    *       | ( SQLRelopExpression() | &lt;LPARENCHAR&gt; SQLExpressionList() &lt;RPARENCHAR&gt; | ( SQLPriorExpression() | SQLSimpleExpressions() ) )
    * </PRE>
    */
   public void visit(SQLRelationalExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;LPARENCHAR&gt; SQLExpressionList() &lt;RPARENCHAR&gt; | ( SQLPriorExpression() | SQLSimpleExpressions() ) )
    * nodeChoice1 -> ( ( SQLInClause() ) | ( SQLBetweenClause() ) | ( SQLLikeClause() ) | IsNullClause() )
    * </PRE>
    */
   public void visit(SQLRelationalExpression n) {
      n.nodeChoice.accept(this);
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;K_NOT&gt; ]
    * nodeToken -> &lt;K_PRIOR&gt;
    * sQLSimpleExpressions -> SQLSimpleExpressions()
    * </PRE>
    */
   public void visit(SQLPriorExpression n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.sQLSimpleExpressions.accept(this);
   }

   /**
    * <PRE>
    * sQLSimpleExpression -> SQLSimpleExpression()
    * nodeListOptional -> ( &lt;COMMACHAR&gt; SQLSimpleExpression() )*
    * </PRE>
    */
   public void visit(SQLExpressionList n) {
      n.sQLSimpleExpression.accept(this);
      if ( n.nodeListOptional.present() ) {
         processList(n.nodeListOptional);
      }
   }

   /**
    * <PRE>
    * nodeChoice -> ( &lt;LPARENCHAR&gt; SQLExpressionList() &lt;RPARENCHAR&gt; | ( SQLPriorExpression() | SQLSimpleExpressions() ) )
    * relop -> Relop()
    * nodeChoice1 -> ( ( [ &lt;K_ALL&gt; | &lt;K_ANY&gt; ] &lt;LPARENCHAR&gt; SubQuery() &lt;RPARENCHAR&gt; ) | SQLPriorExpression() | SQLSimpleExpressions() )
    * </PRE>
    */
   public void visit(SQLRelopExpression n) {
      n.nodeChoice.accept(this);
      n.relop.accept(this);
      n.nodeChoice1.accept(this);
   }

   /**
    * <PRE>
    * relop -> Relop()
    * nodeChoice -> ( ( [ &lt;K_ALL&gt; | &lt;K_ANY&gt; ] &lt;LPARENCHAR&gt; SubQuery() &lt;RPARENCHAR&gt; ) | SQLPriorExpression() | SQLSimpleExpression() )
    * </PRE>
    */
   public void visit(SQLRelationalOperatorExpression n) {
      n.relop.accept(this);
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;K_NOT&gt; ]
    * nodeToken -> &lt;K_IN&gt;
    * nodeToken1 -> &lt;LPARENCHAR&gt;
    * nodeChoice -> ( SQLExpressionList() | SubQuery() )
    * nodeToken2 -> &lt;RPARENCHAR&gt;
    * </PRE>
    */
   public void visit(SQLInClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.nodeToken1.accept(this);
      n.nodeChoice.accept(this);
      n.nodeToken2.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;K_NOT&gt; ]
    * nodeToken -> &lt;K_BETWEEN&gt;
    * sQLSimpleExpression -> SQLSimpleExpression()
    * nodeToken1 -> &lt;K_AND&gt;
    * sQLSimpleExpression1 -> SQLSimpleExpression()
    * </PRE>
    */
   public void visit(SQLBetweenClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.sQLSimpleExpression.accept(this);
      n.nodeToken1.accept(this);
      n.sQLSimpleExpression1.accept(this);
   }

   /**
    * <PRE>
    * nodeOptional -> [ &lt;K_NOT&gt; ]
    * nodeToken -> &lt;K_LIKE&gt;
    * sQLSimpleExpression -> SQLSimpleExpression()
    * </PRE>
    */
   public void visit(SQLLikeClause n) {
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.sQLSimpleExpression.accept(this);
   }

   /**
    * <PRE>
    * sQLSimpleExpressions -> SQLSimpleExpressions()
    * </PRE>
    */
   public void visit(SQLSimpleExpression n) {
      n.sQLSimpleExpressions.accept(this);
   }

   /**
    * <PRE>
    * sQLAdditiveExpressions -> SQLAdditiveExpressions()
    * </PRE>
    */
   public void visit(SQLSimpleExpressions n) {
      n.sQLAdditiveExpressions.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> SQLAdditiveExpression()
    *       | SQLMultiplicativeExpressions()
    * </PRE>
    */
   public void visit(SQLAdditiveExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * sQLMultiplicativeExpressions -> SQLMultiplicativeExpressions()
    * nodeList -> ( ( ( &lt;PLUSCHAR_SUBS&gt; | &lt;PLUSCHAR&gt; ) | ( &lt;MINUSCHAR_SUBS&gt; | &lt;MINUSCHAR&gt; ) | &lt;CONCAT&gt; ) SQLMultiplicativeExpressions() )+
    * </PRE>
    */
   public void visit(SQLAdditiveExpression n) {
      n.sQLMultiplicativeExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> SQLMultiplicativeExpression()
    *       | SQLExpotentExpressions()
    * </PRE>
    */
   public void visit(SQLMultiplicativeExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * sQLExpotentExpressions -> SQLExpotentExpressions()
    * nodeList -> ( ( &lt;ASTERISKCHAR&gt; | &lt;SLASHCHAR&gt; ) SQLExpotentExpressions() )+
    * </PRE>
    */
   public void visit(SQLMultiplicativeExpression n) {
      n.sQLExpotentExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> SQLExpotentExpression()
    *       | SQLUnaryExpressions()
    * </PRE>
    */
   public void visit(SQLExpotentExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * sQLUnaryExpressions -> SQLUnaryExpressions()
    * nodeList -> ( &lt;POW&gt; SQLUnaryExpressions() )+
    * </PRE>
    */
   public void visit(SQLExpotentExpression n) {
      n.sQLUnaryExpressions.accept(this);
      processList(n.nodeList);
   }

   /**
    * <PRE>
    * nodeChoice -> SQLUnaryExpression()
    *       | SQLPrimaryExpression()
    * </PRE>
    */
   public void visit(SQLUnaryExpressions n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> ( ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; ) | ( &lt;MINUSCHAR&gt; | &lt;MINUSCHAR_SUBS&gt; ) )
    * sQLPrimaryExpression -> SQLPrimaryExpression()
    * </PRE>
    */
   public void visit(SQLUnaryExpression n) {
      n.nodeChoice.accept(this);
      n.sQLPrimaryExpression.accept(this);
   }

   /**
    * <PRE>
    * nodeChoice -> &lt;K_NULL&gt;
    *       | FunctionCall()
    *       | OuterJoinExpression()
    *       | TableColumn()
    *       | &lt;S_NUMBER&gt;
    *       | IndicatorBind()
    *       | &lt;LPARENCHAR&gt; SQLExpression() &lt;RPARENCHAR&gt;
    * </PRE>
    */
   public void visit(SQLPrimaryExpression n) {
      n.nodeChoice.accept(this);
   }

   /**
    * <PRE>
    * relObjectName -> RelObjectName()
    * nodeOptional -> [ &lt;DOTCHAR&gt; DotObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] ]
    * nodeToken -> &lt;LPARENCHAR&gt;
    * nodeOptional1 -> [ [ &lt;K_DISTINCT&gt; | &lt;K_ALL&gt; ] ( SQLArguments() | &lt;ASTERISKCHAR&gt; ) ]
    * nodeToken1 -> &lt;RPARENCHAR&gt;
    * </PRE>
    */
   public void visit(FunctionCall n) {
      n.relObjectName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      if ( n.nodeOptional1.present() ) {
         n.nodeOptional1.accept(this);
      }
      n.nodeToken1.accept(this);
   }

   /**
    * <PRE>
    * sQLExpressionList -> SQLExpressionList()
    * </PRE>
    */
   public void visit(SQLArguments n) {
      n.sQLExpressionList.accept(this);
   }

   /**
    * <PRE>
    * relObjectName -> RelObjectName()
    * nodeOptional -> [ &lt;DOTCHAR&gt; DotObjectName() [ &lt;DOTCHAR&gt; DotObjectName() ] ]
    * nodeToken -> &lt;LPARENCHAR&gt;
    * nodeChoice -> ( &lt;PLUSCHAR&gt; | &lt;PLUSCHAR_SUBS&gt; )
    * nodeToken1 -> &lt;RPARENCHAR&gt;
    * </PRE>
    */
   public void visit(OuterJoinExpression n) {
      n.relObjectName.accept(this);
      if ( n.nodeOptional.present() ) {
         n.nodeOptional.accept(this);
      }
      n.nodeToken.accept(this);
      n.nodeChoice.accept(this);
      n.nodeToken1.accept(this);
   }

   /**
    * <PRE>
    * selectWithoutOrder -> SelectWithoutOrder()
    * </PRE>
    */
   public void visit(SubQuery n) {
      n.selectWithoutOrder.accept(this);
   }

}

class FormatCommand {
   public static final int FORCE = 0;
   public static final int INDENT = 1;
   public static final int OUTDENT = 2;
   public static final int SPACE = 3;

   private int command;
   private int numCommands;

   FormatCommand(int command, int numCommands) {
      this.command = command;
      this.numCommands = numCommands;
   }

   public int getCommand()             { return command; }
   public int getNumCommands()         { return numCommands; }
   public void setCommand(int i)       { command = i; }
   public void setNumCommands(int i)   { numCommands = i; }
}

class TreeFormatterException extends RuntimeException {
   TreeFormatterException()         { super(); }
   TreeFormatterException(String s) { super(s); }
}
